# 데이터 저장과 파일

## **목차**
1. 물리적 저장장치
2. 파일
3. 저장장치 관리

# 1. 물리적 저장장치


### **물리적 저장장치의 구성**
1. 저장장치는 데이터 접근속도, 용량을 기준으로 다양한 장치로 구성


    - 레지스터 : CPU 내부의 소규모 고속 저장장치 - (비싸고 빠름)
    - 캐시
    - 메인 메모리
    - 자기디스크, 플래시 메모리
    - 광학디스크, 자기 테이프

### **물리적 저장장치별 특징**

    1. 휘발성
        - 캐시 : 고비용 저장장치로 빠른 접근 속도를 보장.
        - 메인 메모리 : 실제 프로그램과 데이터 적재 공간.

    2. 비휘발성 (속도는 느리지만 영구저장.
    휘발성보다 1000배정도 느림.)
        - 플래시 메모리 : 메인 메모리와 유사하나 비휘발성.(USB 메모리)
        - 자기 디스크 : 데이터베이스 전체를 안정적으로 저장.
        - 광학디스크 드라이브 : CD, DVD, Blue-ray 등.
        - 테이프 장치 : 용량이 크고 저렴하나 순차 접근 방식으로 속도가 매우 느림.

# 2. 파일
    물리적 저장장치
    파일의 구성
    파일 구조화

## **데이터베이스 구성**
    1. 파일  
        : 데이터를 영구정으로 저장하기 위해 사용되는 가장 기초적인 구성 단위.

    2. 블럭
        - 파일을 고정적인 길이로 분할하여 생기는 균등한 크기의 데이터 묶음.
        - 일반적으로 메모리와 디스크간 데이터 전송 단위로 결정.
    3. 레코드
        - 블럭을 구성하는 요소
        - 더이상 분리될 수 없는 최소 데이터 저장 단위.

## **고정 길이 레코드**
    - 고정적인 바이트 수를 갖는 레코드를 저장하는 기법.

```sql
create table (
    char(8),  --8byte
    char(20), --20byte
    char(10), --10byte
    INT )     --4byte
```
- 레코드 하나당 42바이트 크기로 구성됨
- i 번째 레코드 접근 :  (i - 1) * 42 + 1번째 byte부터 42개의 바이트를 읽어 접근.

## **잔여 고정 길이 레코드 할당**

1. 하나의 릴레이션을 여러 블럭에 저장하려고 할 때, 블럭의 길이라 레코드 길이로 정확히 나눠지지 않아 잔여공간을 비워두어야 한다.  
-> 블럭 내에 남은 공간이 낭비됨.

2. 레코드를 두 블럭에 나누어 저장하는 방법.  
-> 나눠진 레코드에 접근시 두 블럭을 접근 (작업시간 2배)

## **고정 길이 레코드 할당의 문제**
1. 레코드 삭제 시
    - 해당 레코드가 저장된 위치에 빈공간이 생성.
    - 장시간 레코드의 삽입 및 삭제 발생시, 저장 공간에 많은 낭비가 발생.

2. 레코드 삭제시 대처 방안
    - 마지막 에코드로 공백 대체
    - 삭제 레코드 이후의 레코드를 이동
    - 가용 리스트 관리

## **레코드 삭제 대처**
1. 마지막 레코드로 공백 대체
    - 검색시간이 늘어남.
2. 삭제 레코드 이후의 레코드를 이동
    - 레코드의 순서가 훼손되지 않아 검색이 빠르게 유지됨
    - 레코드 이동시마다 연산량과 소모시간이 큼.
3. 가용리스트 관리
    - 공백 레코드 포인터에 빈 공간의 링크를 기록.
    - 많이 사용되는 기술.

<br>
<br>
<br>

## **가변 길이 레코드**
1. 블럭에 저장되는 레코드의 길이가 서로 다른(가변적인)레코드를 할당하는 방법.
2. 가변 길이 레코드가 사용되는 상황
    - 한 블럭 내에 저장디는 레코드 유형이 둘 이상.
    - 길이가 고정되지 않은 컬럼의 개수가 하나 이상.
    - 레코드가 `멀티셋`을 허용한 컬럼을 가질 때.
##### # 멀티셋 : 레코드의 컬럼값이 여러 개인 컬럼.

```sql
create table (
    char(8),  --8byte
    varchar(20), --최대 20byte
    char(10), --10byte
    INT )     --4byte
```

- 레코드의 시작과 끝의 위치를 알아야 함.

<img src="https://user-images.githubusercontent.com/66513003/116499346-ed2c9b00-a8e6-11eb-896f-e01bad8ff10f.png" width="400" />

- 첫 4byte는 레코드의 시작위치와 길이를 저장.
- 그다음 고정 길이 레코드를 저장.
- 1byte를 null값으로 저장해 가변 길이 레코드가 시작된다고 표시.
- 가변길이 레코드 저장.

## **슬롯페이지 구조**

- 가변 길이 레코드 저장에 대표적으로 사용되는 구조

<img src="https://user-images.githubusercontent.com/66513003/116499641-a12e2600-a8e7-11eb-9b05-80f268af9432.png" width="400" />

- 블럭헤더 : 이 블럭에 저장된 레코드 개수, 각각의 레코드의 위치 정보들을 요약해 저장.

- 레코드를 블럭의 맨 뒤부터 순서대로 저장.

- 현존하는 저장 구조중 가장 효율적.

<br>
<br>
<br>

## **파일 구조화 방법**

- 파일 수준에서 레코드를 관리하는 방법.

## **파일 구조화 방법의 종류**
- 힙 파일 구조 : 저장순서 고려없이 파일 내 임의의 위치에 배치. ( 저장속도가 가장 빠르지만 사용 효율이 가장 떨어짐.)
- 순차 파일 구조: 레코드들이 탐색키 기준으로 정렬되어 저장. ( 이진탐색으로 빠르게 검색 가능 )
- 해시 파일구조 : 해시 함수를 사용하려 블럭 주소를 계산. (해시 함수에 따라 해시파일구조의 성능차가 난다.)

## **순차 파일 구조의 예**
- 레코드들이 연결구조로 되어있음.
- 레코드가 중간에 추가 / 삭제되는 경우 별도의 작업이 필요.

## **순차 파일 구조**
1. 레코드가 검색키 순서대로 정렬
2. 레코드가 파일에 삽입되는 시점에서 키 값이 부여
3. 장점
    - 검색키에 대한 정렬 연산이 불필요, 키 값들의 순서로 레코드를 판독하는 연산에 효율적.
    - 현재 레코드에서 정렬된 키 순서로 다음 레코드를 찾을 때 부가적인 블럭 접근이 불필요.
    - 이진 탐색을 사용하면 더 빠르게 레코드를 검색
4. 단점
    -레코드 삽입, 삭제에 많은 비용 소요

## **오버플로우 블럭**
1. 순차 파일 구조에서 레코드의 정렬된 상태 유지를 위해 삽입된 신규 블럭.

<img src="https://user-images.githubusercontent.com/66513003/116553141-c301ca00-a934-11eb-861b-551d488bd59c.png" width="400" />

<br>
<br>
<br>

# 3. 저장장치 관리
- 저장장치 접근
- 버퍼관리자
- 버퍼교체전략

## **저장장치 접근**
1. 파일은 논리적 관점에서의 저장 객체
2. 실제 저장될 떄에는 여러 개의 물리적 단위인 블럭으로 저장
    - 블럭은 메모리와 디스크 간 데이터의 전송 단위
    - 일반적으로 2kb ~ 32kb 사용
    - 블럭 전송을 최소화 할수록 입출력 소요 시간이 단축
        - 사용중인 블럭을 지속적으로 메모리에 적재
        - 한정적 공간으로 인하여 필요에 따라 특정 블럭 할당을 해지
        - 메모리 내부에 버퍼라는 공간에 블럭을 저장하고, 이를 관리하기 위해 버퍼 관리자를 사용

<img src="https://user-images.githubusercontent.com/66513003/116561791-97371200-a93d-11eb-968c-a047ea5d9441.png" width="400" />

## **버퍼관리자**

DBMS상의 소프트웨어는 필요한 블럭이 있을 때 버퍼 관리자에게 해당 블럭을 요청
- 요청된 블럭이 버퍼에 있다면, 버퍼 관리자는 블럭이 위치한 메모리 주소를 프로그램에게 전달.
- 요청된 블럭이 없는 경우, 버퍼 관리자는 버터 내의 새로운 공간을 할당하고 해당 블럭을 적재.
- 더이상 적재할 공간이 없다면, 버퍼에 있는 기존 블럭을 선택하여 할당을 해지하고 해당 블럭을 적재.

## **버퍼 관리자의 기능**
- 메모리에 모든 블럭이 가득 차 있을 경우 어떤 블럭을 디스크에 저장할지?

1. 버퍼 교체 전략
    - 가용 공간을 확보하기 위해 기존에 적재된 블럭의 할당을 특정 기분에 의하여 해지.
    -` 미래에 가장 적게 사용될 블럭`을 선택하여 디스크로 내보내는 것이 이상적인 버퍼 교체 전략.
    - 버퍼 교체 전략 기법
        - LRU (Least Recently Used) : 최근에 가장 적게 참조된 블럭을 교체
        - MFU (Mostly Frequently Used) : 특정 기간동안 가장 여러번 사용된 블럭을 선택하여 블럭을 교체

2. 고정블럭
    - 장애로 인하여 메모리의 데이터가 손실되어 작업이 중단될경우, 중단된 작업의 결과물이 디스크에 기록되는 것을 방지.
    - 디스크 블럭이 교체되는 것을 제한.
3. 블럭 강제 출력
    - 시스템 로그와 같이 중요한 데이터는 디스크에 영구적으로 기록되어야 함.
    - 버퍼 공간이 필요 없어도 강제로 디스크에 기록.


# 정리

1. 물리적 저장장치들은 데이터 접근 속도 관점에서 계층적으로 분류된다. 상위계층은 접근 속도가 빠르지만 고가의 장비이며, 하위계층은 접근 속도가 느리지만 저가의 장비이다.

2. 일반적으로 상위의 저장장치들은 전원 공급이 차단되면 데이터가 소멸되는 휘발성이며, 하위의 저장장치들은 전원 공급이 차단되어도 데이터가 소멸되지 않는 비휘발성이다.

3. 데이터베이스는 여러 파일로 구현된다. 파일이란 데이터를 영구적으로 저장하기 위해 사용하는 구조이다. 파일은 물리적으로 여러 블럭으로 나뉘어 저장되기도 한다. 하나의 파일은 다수의 레코드를 저장하고 있다.

4. 레코드의 형식은 고정 길이 레코드와 가변 길이 레코드가 있다. 레코드의 형식에 따라 파일 및 블럭에서 레코드를 관리하는 방식이 달라진다. 특히 슬롯 페이지 구조는 가변 길이 레코드를 관리할 때 이용되는 블럭 구조이다.

5. 특정 필드에 대한 빠른 접근이 요구되는 경우, 파일에 저장되는 레코드를 구조화하는 것이 좋다. 파일 구조화 방법으로는 힙 파일 구조화, 순차 파일 구조화, 해시 파일 구조화가 있다. 파일 구조 중 다중 테이블 군집 파일 구조는 여러 개의 테이블을 하나의 파일에서 관리하는 특수한 파일 구조이다.

6. 메모리와 디스크는 블럭 단위로 데이터를 주고받는다. 이때 데이터베이스 시스템에서는 블럭의 입출력을 최소화하기 위해 메모리 내에 버퍼라는 공간을 만들며, 버퍼를 효율적으로 관리하기 위해 버퍼 관리자를 사용한다.

7. 버퍼 관리자는 버퍼 공간에 대한 추가적인 공간 요청 시 버퍼 교체 전략을 사용하여 사용된 블록을 디스크로 내보내어 공간을 확보한다.