# 연습문제 풀이

Q01. 다음중 물리적 저장 장치를 데이터 접근속도가 빠른 것에서 느린 것 순서로 나열된 것은?

- 답 : `레지스터 - 캐시 - 메인메모리 - 자기디스크`

#

Q02. 다음과 같은 테이블의 스키마에 대해 각 고정 길이 레코드에 할당되는 바이트 수는? (단, INT는 4바이트 길이를 갖는다.)
    
<img src="https://user-images.githubusercontent.com/66513003/117566317-f42a8900-b0f0-11eb-9057-68fc2cdd7b03.png" width="400">

- 10 + 45 + 4 + 13 = 72

- 답 : `72`

#

Q03. 다음은 어떤 파일구조에 대한 설명인가?
```
모든 레코드르 파일 내 임의의 위치에 저장하며, 저장하는 순서를 고려하지 않는 파일 구조
```

- 답 : `힙 파일 구조`

#

Q04. 다음 중 가변 길이 레코드 방식이 필요한 이유가 아닌 것은?

1. 레코드가 멀티셋을 이용하는 컬럼을 가질 때
    - 관계형 모델을 사용하는 DBMS는 기본적으로 하나의 컬럼에는 하나의 값만 가질 수 있는데 이걸 컬럼값의 원자성이라 한다. 한 컬럼에 여러 값을 넣을 수 있는 기능을 멀티셋이라고 한다. 레코드마다 레코드 길이가 다르므로 가변길이 레코드가 필요.
2. 한 블록 내에 저장되는 레코드 유형이 둘 이상일때
    - 한 블록에 서로 다른 레코드 둘이 들어있을 경우 레코드의 길이가 다를 수 있으므로.
3. 길이가 고정되지 않은 컬럼이 한 개 이상일 때
    - var 형식을 갖는 컬럼 등.
4. `레코드의 수정이 매우 자주 발생할 때`

#

Q05. 가변 길이 레코드를 저장하기 위해 파일 또는 블록의 헤더에 유지하는 다음과 같은 형식의 구조를 무엇이라고 하는가?

<img src="https://user-images.githubusercontent.com/66513003/117566598-8a12e380-b0f2-11eb-96f2-de4d6e527ac6.png" width="400">

- 각각의 슬롯에 각각의 가변 길이 레코드가 들어가고 각각의 레코드에 대해 시작과 끝점을 블럭 헤더에 기록. 몇 번째 레코드를 가져오기 위해서는 몇바이트부터 몇번까지 접근한다는 정보를 담아놔서 가변 길이 레코드를 사용할 수있게 해줌.

- 답 : 슬롯 페이지 구조

#

Q06. 다음 중 요청된 레코드에 빠르게 접근할 수 있도록 하는 구조인 인덱스의 효율성에 대한 평가기준이 아닌 것은?

1. 새로운 데이터 삽입 시 발생하는 인덱스 구조 유지 비용
2. 인덱스를 통해 데이터를 찾고 접근하는데 걸리는 시간
3. 인덱스를 저장하기 위해 부가적으로 필요한 공간 비용
4. `사용자의 인덱스를 사용하는 질의 요청 빈도`

#

Q07. 다음의 설명은 어떤 인덱스에 대한 설명인가?
```
모든 탐색키 값에 대해 탐색키 <값, 포인터> 쌍으로 구성된 인덱스 엔트리를 갖는 인덱스로 인덱스 파일의 크기가 커서 I/O 비용이 증가하여 탐색 시간이 오래 걸릴수 있는 단점을 지님
```

- 답 : 밀집 인덱스

#

Q08. 다음을 B+트리의 예시이다. 이순신을 탐색하는 과정에서 거치는 포인터를 올바를 순서로 나열한 것은?

<img src="https://user-images.githubusercontent.com/66513003/117566840-efb39f80-b0f3-11eb-8668-373fc9d9aea2.png" width="400">

- 답 : `1, 5, 8`

#

Q09. 다음 그림에서 검색키를 버킷 주소에 대응시키는 h를 무엇이라고 하는가?

<img src="https://user-images.githubusercontent.com/66513003/117566928-74062280-b0f4-11eb-8a87-46fdb3c404e5.png" width="400">

- 답 : `해시함수`

Q10. 서로 다른 두 레코드 R1과 R2의 검색키가 h에 의해 동일한 버킷으로 대응되었을 때, R1과 R2를 무엇이라고 하는가?

<img src="https://user-images.githubusercontent.com/66513003/117566928-74062280-b0f4-11eb-8a87-46fdb3c404e5.png" width="400">

- 충돌 : 서로 다른 탐색키가 같은 버킷에 대응됨
- 오버플로우 : 버킷에 더이상 들어갈 공간이 없음.
- 동거자 : 검색 키가 서로 다르지만 같은 버킷에 배치가 될 때

- 답 : `동거자`

#

Q11. 데이터베이스의 크기에 따라 버킷의 개수 즉, B1, B2, ... , Bn이 조절되는 형태의 해싱을 무엇이라 하는가?

<img src="https://user-images.githubusercontent.com/66513003/117573604-d589b980-b113-11eb-9347-c3f5b91ba000.png" width="400">


- 정적 해싱 : 해시 함수가 특정 버킷에 바로바로 대응시킴.
- 동적 해싱 : 디렉터리라고 하는 또 다른 구조를 사용해서 해시와 디렉토리 이걸 가지고 버킷의 사이즈를 늘릴 수 있는 해시.

- 답 : `동적 해싱`

#

Q12. 다음과 같은 테이블에 대해 성별 컬럼에 비트맵 인덱스를 생성할 때, '남자'에 대한 비트 열로 올바른 것은?


<img src="https://user-images.githubusercontent.com/66513003/117573634-feaa4a00-b113-11eb-90fe-04d2a1f1c7aa.png" width="400">

- 답 : `1110100`

#

Q13. 다음 중 트랜잭션의 특성이라고 할 수 없는 것은?

- 트랜잭션의 반드시 만족시켜야 하는 4가지 특성 : ACID 원자성 일관성 독립성 지속성

1. `확장성`
2. 원자성
3. 독립성(고립성)
4. 지속성

#

Q14. 다음 중 트랜잭션을 동시에 실행시키는 목적에 대한 설명으로 옳지 않은 것은?

1. `데이터베이스의 일관성일 향상된다.`
2. 데이터의 가용성을 향상시킬 수 있다.
3. 트랜잭션의 대기시간을 감소시킬 수 있다.
4. 트랜잭션의 처리율과 자원의 이용률이 향상된다.

#

Q15. 다음 빈칸에 알맞은 말은?
```
스케줄에 대한 대기 그래프가 (       ) 을/를 포함하면, 그 스케줄은 교착상태에 있다는 것을 의미한다.
```

- 답 : `사이클`

#

Q16. 다음 중 아래의 스케줄과 `충돌 동등`한 스케줄이 스케줄이 아닌 것은?

<img src="https://user-images.githubusercontent.com/66513003/117573976-ed623d00-b115-11eb-9cf9-d630b4c26124.png" width="200">

<img src="https://user-images.githubusercontent.com/66513003/117573989-05d25780-b116-11eb-935e-2e93a4506cfa.png" width="400">

- 123은 결과가 바뀌지 않지만 4번은 데이터가 훼손됨.
- 답 : 4

#

Q17. 다음은 무엇에 대한 설명인가?

```
두 트랜잭션 순서쌍 Ti와 Tj에 대해, Ti가 기록한 데이터 항목을 Tj가 읽는다면, Ti의 커밋이 Tj의 커밋보다 먼저 나타나는 스케줄.
```

- 답 : 회복 가능한 스케줄

#

Q18. 락 기반 규약을 사용하는 시스템에서 다음의 두 트랜잭션이 병렬적으로 실행될 경우 어떤 스케줄이 작성될 수 있는가?

<img src="https://user-images.githubusercontent.com/66513003/117574158-c3f5e100-b116-11eb-8ad5-815c4fd73d1b.png" width="400">

- 언락을 맨뒤로 밀었기 때문에 교착상태가 될 가능성이 높음

- 답 : `교착상태 포함 스케줄`

#

Q19. 교착상태 회복을 위해 교착상태의 트랜잭션 집합이 주어지면 교착상태를 해결하기 위해 롤백시킬 트랜잭션을 결정한다. 이때 롤백 대상 트랜잭션을 무엇이라 하는가?

- 답 : `희생자`

#

Q20. Write연산을 수행할 때 마다 데이터베이스가 변경되기 전에 로그 레코드를 우선 로그에 추가하는 방식을 무엇이라 하는가?

- `WAL (Write Ahead Log)`

#

Q21. 다음 중 체크포인트 방생 시 수행되는 작업이라고 할 수 없는 것은?

1. `다음 체크포인트 발생 주기를 결정한다.`
2. 현재 메인 메모리에 존재하는 모든 로그 레코드를 안정 저장장치에 기록한다.
3. 수정된 모든 버퍼 블록을 디스크에 반영한다.
4. 로그 레코드 <checkpoint ListT>를 안정 저장장치에 기록한다.

#

Q22. checkpoint  로그 레코드의 ListT의 값으로 올바른 것은?

<img src="https://user-images.githubusercontent.com/66513003/117574389-c86ec980-b117-11eb-8e57-3071487b1432.png" width="200">

- 답 : {T0, T1}

#

Q23. 위 로그를 통해 Redo를 수행해야 하는 트랜잭션은?

<img src="https://user-images.githubusercontent.com/66513003/117574389-c86ec980-b117-11eb-8e57-3071487b1432.png" width="200">

- 답 : T0, T1