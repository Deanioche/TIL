# Hashing과 특수 인덱스

## **목차**
1. 정적 해싱 

2. 동적 해싱

3. 비트맵 인덱스

# 정적 해싱
- 해시의 구조
- 해시 파일 구조
- 해시 인덱스

## 해싱의 개념
1. 해시(Hash)
- 탐색키에 산술적인 연산을 통해 버킷의 주소를 계산하는 해시 함수를 사용하여 데이터 배분 및 접근하는 기법. 

2. 버킷(bucket)
-한 개 이상의 레코드를 저장할 수 있는 저장공간의 단위.
- 크기는 일반적으로 디스크 블록의 크기와 일치.

<img src="https://user-images.githubusercontent.com/66513003/117237424-e9a88f00-ae65-11eb-8bad-9f832fd486c4.png" width="400">

## 해시함수 

`h(K3) = h(K7) = 3`

- 해시함수는 되도록 균등하게 배분이 가능하도록 설계를 해주어야 하지만 균등분배는 이론적으로만 가능하고 한쪽으로 몰리지만 않게 하는것이 일반적.

<img src="https://user-images.githubusercontent.com/66513003/117240955-f11f6680-ae6c-11eb-9509-32c38b48d577.png" width="400">

<img src="https://user-images.githubusercontent.com/66513003/117240976-fd0b2880-ae6c-11eb-948e-c218a7465946.png" width="400">

<img src="https://user-images.githubusercontent.com/66513003/117241000-0ac0ae00-ae6d-11eb-8285-9356da21d286.png" width="400">


## 해시 파일 구조
`h(k) = k % 6`
레코드별 고유 번호의 끝번호를 6으로 나눈 나머지 값을 기준으로 6개의 버킷으로 분배.

## 정적 해싱의 특징
1. 버킷의 개수가 고정된 해싱 기법
2. 키 값이 𝐾𝑖인 레코드 삽입.
    - ℎ(𝐾𝑖)를 통하여 𝐾𝑖에 대응하는 버킷 주소를 생성하고 레코드를 해당 버킷에 저장.
3. 키값이 𝐾𝑖인 레코드 검색
    - ℎ(𝐾𝑖)을 통하여 버킷 주소를 생성하고 버킷에 저장된 레코드 접근.
    - ℎ(𝐾𝑖) = ℎ(𝐾𝑗) = m 인 경우가 발생하기 때문에 버킷 m 에 저장된 모든 레코드를 탐색하여 선택하는 과정이 필요

## 충돌과 동거자
1. 충돌 : 서로 다른 두 레코드가 동일한 버킷에 대응. 탐색키가 다른 두 레코드가 동일한 버킷 id를 제공.

2. 동거자 : 충돌에 의해 같은 버킷 주소를 갖는 레코드.

## 오버플로(overflow)
- 버킷에 레코드를 저장 할 수 있는 여유 공간이 없는 상황이 발생.
- 추가적인 버킷을 할당 또는 다음 버킷에 할당하여 처리.
3. 오버플로우가 발생할수록 접근시간이 길어지고 해시 성능이 저하.
    - 오버플로우가 많이 발생하는 해시함수는 사용x.

- 방법1 : 버킷 B2가 가득차면 -> B2-1에 저장
- 방법2 : 버킷 B2가 가득차면 -> B3에 저장

## 해시 인덱스
- 실제 버킷에 저장되는건 인덱스 엔트리
1. 해시 파일 구조와 동작 방식을 레코드가 아닌 인덱스 엔트리에 적용한 인덱스.

<img src="https://user-images.githubusercontent.com/66513003/117242486-53c63180-ae70-11eb-89cf-b5909650e3ad.png" width="400">

- 윤봉길 레코드의 해시 엔트리는 해시함수대로면 0번 버켓에 저장되어야 하지만 0번과 1번 버켓이 오버플로우가 발생해서 2번에 저장됨.

## 정적 해싱의 문제
1. 데이터베이스의 크기가 커짐에 따른 성능 감소.
2. 미리 큰 공간을 잡을 경우 초기에 상당한 양의 공간이 낭비됨.
3. 재구성시 새롭게 선택된 해시 함수를 사용하여 모든 레코드에 대하여 다시 계산하고 버킷에 할당하는 대량의 비용이 발생.
     - 해시 구조의 크기가 동적으로 결정되는 동적 해싱 기법 제안.
    
<br>
<br>
<br>

## 동적 해싱
- 동적 해싱의 개념
- 확장성 해싱
- 확장성 해싱의 구조

## 동적 해싱의 개념
1. 동적 해싱의 정의
    - 버킷의 개수를 가변적으로 조절할 수 있는 해싱 기법.
    - 데이터베이스의 크기에 따라 버킷의 크기가 비례
2. 데이터베이스의 증대 혹은 축소에 따른 인덱스의 구조를 조절하기 위해 해시 함수를 동적 변경하는 기술.
3. 확장성 해싱
    - 동적 해싱의 일종으로 디렉터리와 버킷의 2단계 구조
    - 디렉터리는 디스크에 저장되는 버킷 주소 테이블.
    - 디렉터리 깊이를 의미하는 정수값 d를 포함하는 헤더와 데이터가 저장된 버킷에 대한 2^d개의 포인터로 구성.

## 확장성 해싱
1. 모조키(pseudo key)
    - 레코드의 탐색키 값이 해시 함수에 의해 일정 길이의 비트 스트링으로 변환된 키.
    - 모조키의 첫 d비트를 사용하여 디렉터리에 접근.
2. 버킷 헤더
    - 정수값 𝑖( ≤ 𝑑 )가 저장되어 있음을 표시
    - 𝑖 는 버킷에 저장되어 있는 모조키들이 처음부터 𝑖 비트까지 일치함을 표시

<img src="https://user-images.githubusercontent.com/66513003/117243411-2f6b5480-ae72-11eb-926e-eb5d6fb871a7.png" width="400">

- 탐색키 K3에 해시함수를 이용해 h(K3)로 모조키를 만들어낸다.
- 디렉터리에 명시된 버킷 헤더값과 모조키를 비교해 일치하는 `모조키 시작 비트 스트링`을 찾는다.
- 모조키가 101000010001 이라면 `모조키 시작 비트 스트링` 중에서 맨 첫 비트 하나만 보는 버킷 B4에만 해당하므로 B4에 모조키에 해당하는 인덱스 인트리가 있다는 뜻이므로 B4에서 탐색키 K3에 해당하는 레코드 접근 포인트를 알아낼 수 있다.

## 확장성 해싱의 구조
- 모조키에 해당되는 레코드를 새롭게 삽입하는 경우. 
- 절차를 따라 해당하는 버킷 B4에 저장하려 할때 B4에서 오버플로우가 발생.
- 다음 버킷에 저장 할 수도 있지만, 새로운 버킷을 추가할 수도 있다.

1. 레코드 삽입에 의해 분할된 확장성 해싱 파일.

<img src="https://user-images.githubusercontent.com/66513003/117244729-8a05b000-ae74-11eb-8f22-f6915690d06f.png
" width="400">

- 오버플로우가 일어난 버킷 B4을 분할해
1이었던 `모조키 시작 비트 스트링`을 10과 11로 나누고 인덱스 엔트리들을 분배해 저장.
- 버킷을 추가해 재분배함으로써 오버플로우 발생을 방지하지만, 성능에는 큰 영향을 주지 않는다.

<br>
<br>
<br>

# 비트맵 인덱스
- 비트맵 인덱스의 구성
- 비트맵 인덱스의 사용
- 비트맵 인덱스의 특징

## 비트맵 인덱스의 개념
1. 탐색키의 중복 비율이 높은 컬럼을 대상으로 하는 질의를 효율적으로 처리하기 위해 고안된 특수한 형태의 인덱스

2. 비트맵
    - 간단한 비트의 배열
    - 릴레이션 r의 속성 A에 대한 비트맵 인덱스는 A가 가질 수 있는 값에 대해 비트맵을 구성
    - 각 비트앱은 릴레이션에 있는 레코드의 수 n개 만큼 n개의 비트로 표현

## 비트맵 인덱스 구성
1. i번째 레코드가 컬럼 A에 해당 값을 가지면 비트맵의 i번째 비트를 1로, 그렇지 않으면 0으로 설정.

<img src="https://user-images.githubusercontent.com/66513003/117245677-2ed4bd00-ae76-11eb-87ae-7e35067103ff.png
" width="400">

<img src="https://user-images.githubusercontent.com/66513003/117245860-82dfa180-ae76-11eb-88d5-4924d40e640e.png" width="400">

- 비트열의 길이는 컬럼수만큼 만들어지고 해당 레코드의 값과 일치하면 1, 아니면 0

<img src="https://user-images.githubusercontent.com/66513003/117246167-15804080-ae77-11eb-981b-c10cb6172917.png" width="400">

- SQL문의 2개의 조건에 맞춰 생성한 2개의 비트맵의 합집합(AND)을 구해 전체 레코드와 비교해 일치하는 레코드를 출력.

## 비트맵 인덱스의 특징

1. 비트맵의 활용
    - 컬럼에 대한 값의 범위가 유한하고 (일반적으로 10개 이하) 비교적 개수가 적은 규모일 때 용이.
    
    - 적용 : 직책, 학과, 혈액형 등 가지수가 많지 않고 `중복의 비율`이 높은 컬럼에 대해 빠른 검색 속도를 제공

    - 종류가 많거나 중복이 없는 `기본키`같은 컬럼에는 사용하지 않는다.

2. 비트맵 인덱스의 크기
    - 레코드의 크기가 수백 바이트 이상이 되어도 비트맵 인덱스에서는 하나의 인덱스에서는 하나의 비트로 표시.
    - 실제 릴레이션 크기에 비해 매우 작은 것이 장점.


# 정리하기

- 해싱은 수학적 함수 개념을 사용한 데이터 관리 기법으로 버킷의 개수가 정해진 정적 해싱과 데이터베이스이 크기에 따라 버킷의 개수가 변경되는 동적 해싱으로 구분된다.

- 해시 함수는 레코드의 탐색키 값과 저장되어야 하는 버킷의 주소를 대응시키는 역할을 수행하며, 레코드가 버킷에 균등하게 배푼되는 해시 함수가 가장 이상적이다.

- 충돌 발생으로 서로 다른 탐색키가 동일한 버킷에 대응될 수 있으며 이를 동거자라고 한다. 특정 버킷에 많은 충돌이 발생하여 더 이상의 레코드나 인덱스 엔트리가 저장될 수 없을 때 이를 오버플로라 한다.

- 확장성 해싱은 데이터베이스의 크기에 따라 버킷이 확장되는 동적 해싱 기법의 일종으로 디렉토리와 버킷으로 구성되며 디렉토리의 주소와 버킷의 주소로 구성되는 모조키를 사용한다.

- 비트맵 인덱스는 다중키를 가진 질의를 보다 효율적으로 처리하기 위해 고안된 인덱스이다. 비트맵은 간단한 비트 배열로 이루어져 있다.

- 비트맵 인덱스를 사용하여 레코드를 검색 시 주어진 각각의 조건에 해당하는 비트열을 비트 AND 연산을 수행하여 최종적으로 생성되는 비트열로 조건을 만족하는 레코드의 위치를 빠르게 파악할 수 있다.