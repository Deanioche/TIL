# 동시성 제어

## 용어
- **양립성 함수**  
락의 종류에 따라 동시에 수락 될 수 있는지 판단하는 함수
- **2단계 락킹 규약**  
요청 단계에서 트랜잭션은 락을 추가 요청할 수 있으며, 반납 단계 부터는 락을 반납만 해야 하는 방식으로 직렬성을 보장하는 규약
- **토마스 기록 규칙**  
타임스탬프 기반 규약의 규칙으로 오래된 쓰기를 무시하는 규칙
- **교착상태**  
특정 트랜잭션 집합 내에 속하는 모든 트랜잭션이 집합 내의 다른 트랜잭션을 기다리고 있는 상태
#
## **목차**

1. 락 기반 규약
2. 타임스탬프 기반 규약
3. 교착상태
#

## **락 기반 규약**
- 락 기반 규약의 개념
- 락 양립성
- 2단계 락킹 규약

## 동시성 제어의 개념

1. 트랜젝션 직렬화와 회복화는 스케줄이 데이터 일관성에 영향을 미치는 여부를 판별하고 일관성이 유지되는 상태로 복원시키기 위해 정의한 개념.

2. 일관성훼손을 발생시키는 트랜잭션에 대해 동시성 제어를 통해 일관성 유지에 개입

   - 트랜잭션간 연산의 순서를 제어
   - 어떠한 데이터 읽기, 갱신 연산에도 무결성을 유지
   - 동시에 실행되는 트랜잭션 수를 증가

3. 동시성 제어 규약
   - 락 기반 규약
   - 타임스탬프 규약
   - 검증 기반 규약

## 락 기반 규약의 개념

1. 직렬가능성을 보장하기 위해락(잠금)을 사용하여 데이터 항목에 연산적용 전트랜잭션이락을 획득하고 연산후 반납하도록 하는 규약

   - 데이터를 읽거나 쓸려고 할 때, 이거 내가 지금 쓸 거니까 아무도 쓰지 마라고 해서 데이터를 자기 메모리에 옮겨놓고 그 데이터에 락을 잠금장치를 걸어서 다른 트랜잭션이 읽지 못하도록 만들어 주는 그런 형태의 규약

2. 락의 종류

   - 공유락(sharedlock:S):트랜잭션 T가 LS(Q)명령으로 데이터 항목 Q에 공유락을 획득하면 T는 Q를 읽을 수는 있지만 쓸 수는 없는 락

     - 이거 내가 락을 걸었지만 너가 락을 걸어도 괜찮아라고 하는 락
     - 공유 락은 보통 읽기 작업만 할 때 사용

   - 배타락(exclusivelock:X):트랜잭션 T가 LX(Q)명령으로 데이터 항목 Q에 대한 배타락을 획득하면, T가 Q를 읽고쓸 수있는 락
     - 내가 락 걸었어 그런니 아무도 락 못걸어 쓰지마라고 하는 식으로 굉장히 배타적인 락
     - 읽기도 하고 그 다음에 쓰는 작업도 수행하려고할 때

## 락 양립성

1.  트랜잭션은 연산하고자하는 데이터에 대한락을 획득해야만 연산 진행 가능

2. 락 양립성 함수

<img src="https://user-images.githubusercontent.com/66513003/117435798-3628c300-af69-11eb-9bca-fa1e94e1e790.png" width="400">

<br>
- 공유락은 다른 공유락과 양립 가능
- 배타락과 다른락과 양립불가능
- 배타락의 요청은 공유락이 반납될 때까지 대기
- 락의 반납은 UN()명령 사용

## 락 반납 지연의 문제
1. 출력: 1. 𝑇12, 𝑇13에 대한 부분 스케줄
- 𝑇12이 B에 대한 배타락을 반환할 때까지 𝑇13은 대기
- 𝑇13이 A에 대한 공유락을 반환할 때까지 𝑇12는 대기

<img src="https://user-images.githubusercontent.com/66513003/117436221-b5b69200-af69-11eb-9125-58fb52d97924.png" width="400">

### **교착상태(deadlock)**
- 두 트랜잭션 중 하나를 롤백 
- 한 트랜잭션이 롤백되면 그 트랜잭션이 획득했던 모든 락은 반납

- 락을 너무 일찍 반납하면 일관성이 훼손되고 너무 늦게 반납하면 교착상태가 발생하므로 2단계 락킹 규약이 마련됨.

## 2단계 락킹 규약 (2PL)

1. 트랜젝션은 락을 요청, 반납하는 두 담계로 구성
- 확장단계 : 락을 얻을 수 있으나, 반납할 수 없는 단계
- 축소단계 : 락을 반납할 수는 있지만 새로운 락을 얻을 수 없는 단계

2. 직렬성을 보장하나 교착상태 예방 불가

#

## **타임스탬프 순서 규약**

- 타임스탬프 순서 규약의 개념
- 타임스탬프 순서 규약의 적용
- 토마스 기록 규칙

## 타임스탬프 기반 규약의 개념
1. 각 트랜잭션 𝑇𝑖 실행의 순서를 판단하기 위해 타임스탬프 TS(𝑇𝑖)를 부여.

2. 데이터 항목에 대한 타임 스탬프 할당.
   - W-TS(Q) : Write(Q)를 성공적으로 실행한 트랜잭션 중 가장 큰 타임 스탬프
   - R-TS(Q) : Read(Q)를 성공적으로 실행한 트랜잭션 중 가장 큰타임 스탬프

3. 타임스탬프 할당 방법
   - 시스템 클럭 값
      - 보통 일반적으로 DBMS는 시스템 클럭 값을 가지고 많이 사용
   - 논리적 계수기


## 𝑇𝑖가 Read(Q)를 수행할 때
- 타임 스탬프 순서 규약은 먼저 들어오는 트랜젝션(타임 스탬프가 작은 쪽)은 먼저 처리될 수 있도록 만드는 순서 규약.

<img src="https://user-images.githubusercontent.com/66513003/117462741-ea3a4600-af89-11eb-8668-f88b9849bf4a.png" width="400">

```
- Ti가 시작되고 Tj가 나중에 시작됨.
- Ti의 연산이 시작되기 전에 Tj의 write연산이 수행됨. 
   -> Tj의 타임 스탬프 값이 WTS에 적용됨.
- Ti의 Read(Q)를 처리.
```
- Ti가 이미 Tj에 의해 변경된 Q값을 읽기 때문에 잘못된 값을 읽게됨.
1. Ti의 타임스탬프 값이 Q에 대한 Write-타임스탬프 값보다 작기 때문에 잘못된 값을 읽고나서 처리할수 없어 Ti를 `롤백`시킨다.
   - TS(𝑇𝑖) < W-TS(Q) 이면 Read연산이 거부되고 𝑇𝑖는 롤백.

2.  W-TS(Q)의 값이 TS(Ti)값 보다 작으면 `정상적으로 수행`되고 Q에 대한 R-TS값은 Ti의 타임스탬프 값으로 설정된다.
   - TS(𝑇𝑖)≥ W-TS(Q)이면 Read연산이 수행되고 R-TS(Q)는 기존 R-TS(Q)와 TS(𝑇𝑖)중 최대값으로 설정



## 𝑇𝑖가 Write(Q)를 수행할 때

<img src="https://user-images.githubusercontent.com/66513003/117466962-38514880-af8e-11eb-9a28-f6d3f83f818e.png" width="400">

- Ti가 먼저 시작됐기 때문에 Tj는 Ti의 Write(Q)가 수행된 이후의 값을 읽었어야 했는데 그 전에 먼저 읽어버려서 잘못된 값이 읽혀버림.

<img src="https://user-images.githubusercontent.com/66513003/117469395-a39c1a00-af90-11eb-8aca-2d7c69d30b00.png" width="400">

- Tj가 먼저 Write(Q)를 수행 후 Ti가 Write(Q)를 수행 해버려서 Tj가 쓴 값은 무시됨.  
-> Ti:Write(Q)를 Tj:Write(Q)전에 수행하면 정상적으로 수행이 되고, W-TS(Q)의 값은 Ti의 TS값으로 설정된다.


1. TS(𝑇𝑖) < R-TS(Q) 또는 TS(𝑇𝑖) < W-TS(Q) 이면 Write 연산이 거부되고 Ti는 롤백.
2. 그렇지 않으면 Write 연산을 수행하고 W-TS(Q)는 TS(𝑇𝑖)로 설정

## 타임스탬프 기반 규약의 적용
1. TS(𝑇14) < TS(𝑇15)
<img src="https://user-images.githubusercontent.com/66513003/117470294-9b90aa00-af91-11eb-8535-b7fa485273fd.png" width="400">

- T14는 두개의 계좌 값을 읽어 합계값을 출력.
- T15는 계좌B에서 계좌A로 1000원을 이체

<img src="https://user-images.githubusercontent.com/66513003/117470477-d0046600-af91-11eb-8b8c-ed868c009f1c.png
" width="400">
- 스케줄이 생성됨
- Read(B)를 하려고 할때 살펴봐야 할 건 B에 대한 Read TS값. W-TS값도 영향을 미치는데 지금 현재 T14는 W-TS를 한 적이 없기 때문에 아무런 문제없이 Read(B)를 수행할 수 있다.

- Write(B)를 하려고 할때는 B에대한 R-TS값과 W-TS값을 따져봐야 한다. 현재 B에 대한 W-TS, R-TS값이 Write(B)보다 작은 상태이므로 수행해도 문제가 없다.

- Read(A)는 이전에 A에 대해 R-TS도 W-TS도 한 적이 없다. 즉, 현재 R-TS와 W-TS값은 0이므로. Read(A)가 수행이 되며 T14의 TS값이 R-TS(A)값이 된다.

- T15:Read(A) Read연산은 순서가 상관이 없으므로 정상처리.

- T15:Write(A) : A에 대한 W-TS, R-TS값 모두 따져야 한다. 현재 A에 대한 W-TS, R-TS값이 모두 T15:Write(A)보다 작으므로 수행에 문제가 없음.

### **이 스케줄은 `일관성을 훼손시키지 않음`**

## 토마스 기록 규칙
1. TS(𝑇𝑖) < R-TS(Q)이면 Write 연산이 거부되고 𝑇𝑖 는 롤백
2. TS(𝑇𝑖) < W-TS(Q)이면 Write 연산은 거부된다.
   - 롤백 부분을 지워버림
   - Write 연산만 무시하고 나머지는 Ti의 트랜젝션 그대도 처리
   - 롤백 연산이 DBMS에 주는 부담을 줄여  개선
3. 그렇지않으면 Write연산을 수행하고 W-TS(Q)는 TS(𝑇𝑖)로 설정

<img src="https://user-images.githubusercontent.com/66513003/117473571-15766280-af95-11eb-8f57-27ea656d73e3.png" width="400">

- Write 이후에 Read되었어야 할 값을 먼저 읽어서 문제가 될 수 있기때문에 롤백해야 하지만

<img src="https://user-images.githubusercontent.com/66513003/117473804-51112c80-af95-11eb-9ed3-991daa3b774e.png" width="400">

- Read가 아닌 Write가 먼저 수행된 경우에 한해서는, 최종적으로 남아야 할 값을 Tj:Write(Q)이므로 Ti:Write(Q)때문에 롤백 할 필요 없이 무시만 해주면 이후에도 아무런 문제가 없다. (토마스 기록 규칙 2번)

#
## **교착상태**
- 교착상태의 개념 
- 교착상태 방지
- 교착상태의 회복

## 교착상태(Deadlock)의 개념
1. 특정 트랜젝션 집합 내에 속하는 모든 트랜젝션이 집합 내의 다른 트랜젝션을 기다리고 있는 상태
   - A가 B를, B가 C를, C가 A를 기다림.

<img src="https://user-images.githubusercontent.com/66513003/117474638-178cf100-af96-11eb-84ed-ba940784ab98.png" width="400">

- 두 트랙잭션 중 하나를 반드시 롤백해야 한다.

## 교착상태 처리 방법

1. 교착상태 발생이 비교적 높은 시스템의 경우
- 교착상태 방지 규약사용 
   - `모든` 데이터 항목에 대해 락을 설정하는 기법
   - 예 : 트랜젝션 A에서 데이터 123를 사용할때 데이터 123에 대한 모든 데이터 락을 다 확보한 뒤에 트랜젝션을 처리하고 실행.
      - 단점 1 : 트랜잭션이 시작되기 전에 어떤 데이터에락을 걸어야 하는지 미리 알기가 어려움.
      - 단점 2 : 락이 걸린 상태에서 많은 데이터들이 오랫동안 사용되지 않아 데이터 항목에 대한 `자원 이용률`이 매우 낮아짐.
   - 타임스탬프를 이용한 `선점유기법` 

2. 교착상태 발생이 비교적 높지않은 시스템의 경우
   - 미리 교착방지규약을 사용해 DBMS 성능을 떨어뜨리는 것은 비효율적이므로 규약을 설정하지 않다가 문제가 발생하면 롤백을 수행.
   - `교착상태 탐지`와 `회복 기법` 사용 
   - `교착상태 탐지` : 교착상태가 발생해도 트랜젝션에서 DBMS로 알아서 알리지 않으므로 일정 시간마다 DBMS에서 특정 알고리즘을 돌려 교착상태인 트랜젝션을 탐지.
   - `회복 기법` : 트랜젝션을 롤백시켜서 해결하는 것.
      - 대기 그래프 
      - 희생자 선정

## 교착상태 방지
1. 타임스탬프를 이용
   - 𝑇𝑗가 락을 소유한 데이터 항목을 𝑇𝑖가 요청하는 상황 
      -  wait-die기법(비선점유 기반): TS(𝑇𝑖) < TS(𝑇𝑗)일 때 Ti가 기다리고 그렇지 않으면 Ti를 롤백.
      - Ti가 먼저 실행된 트랜젝션의 경우 Tj가 락을 반납할 때까지 기다린다.
      - Tj가 먼저 실행됐을 경우 Ti를 롤백.
      - 되도록이면 대기 상태를 만들지 않고 롤백을 시켜버리는 기법.
      
   - 선점 : 어떤 특정 값에 의해서 우선 순위를 매겨놓고 이 우선순위에 의해서 먼저 작업이 처리되도록 만듬. 
   - wait-die기법은 비선점 기법이기 때문에 우선 순위에 의해서 작업을 처리하지 않음.

   <img src="https://user-images.githubusercontent.com/66513003/117476861-473cf880-af98-11eb-83a7-e3bf0688044a.png" width="400">

   - TS(T18)보다 TS(T19)값이 더 크다. (T18이 먼저 실행되었다.)
   - T18이 T19가 걸어놓은 Q에 락을 요청할 경우, T18은 대기 상태가 됨.

   <img src="https://user-images.githubusercontent.com/66513003/117477156-9edb6400-af98-11eb-8281-cd53a1ebed1b.png" width="400">

   - T20이 나중에 실행되었고 T19가 먼저 Q에 대한 락을 가지고 있음.
   - 이 때, T20이 T19가 락을 걸어놓은 Q에 락을 요청하면 T20은 T19보다 타임스탬프 값이 크므로 wait-die 기법에 의해서 롤백을 시킬 수 밖에 없음.

- wound-wait 기법(선점유 기반) : S(𝑇𝑗) < TS(𝑇𝑖), 𝑇𝑖가 기다리고 그렇지 않으면 Tj를 롤백하고 락을 이양.
   - 타임스탬프가 낮은 거는 먼저 실행되었기 때문에 락을 요구할 권리가 있다.
   - TS가 큰 트랜젝션이 먼저 실행된
    트랜젝션에 락을 요구할 경우에는 기다린다.

<img src="https://user-images.githubusercontent.com/66513003/117477757-58d2d000-af99-11eb-805b-f6ebb6c9e138.png" width="400">

- T18이 T19가 가지고 있는 락을 요청.
- T18은 Q에 대한 락을 바로 획득.
- T19는 Q에 대한 락을 해제하고나서 바로 롤백 (우선순위가 T18이 더 높으므로)

<img src="https://user-images.githubusercontent.com/66513003/117478027-a3544c80-af99-11eb-8118-40cdd77a963f.png" width="400">

- T20이 T19가 가지고있는 Q에 대한 락을 요구.
- T20은 T19보다 TS값이 높으므로 (나중에 실행되었으므로) T19가 락을 해제할 때까지 대기.

## 교착상태 탐지와 회복
1. 교착상태 발생이 비교적 높지않은 시스템의 경우주기적으로 교착상태를 탐지하고 발생 시 회복절차를 수행 

2. 탐지및 회복절차
   - 트랜잭션이 할당된 데이터 항목과 현재 요청되고 있는 데이터 항목에 대한 정보를 유지
      - 어떤 트랜젝션이 어떤 데이터 항목을 가지고 있는지 파악. 또 다른 트랜젝션이 실행된다고 하면 이 트랜젝션이 어떤 데이터 항목을 추가적으로 요청하고 락을 걸었는지의 정보를 저장.
   - 교착상태가 발생 여부를 판별하기 위해 시스템의 상태를 검사하는 알고리즘을 주기적으로 수행
   - 교착상태가 검출되면 시스템은 교착상태로부터 회복을 위한 절차를 수행

## 교착상태 탐지
1. 대기 그래프(wait-for graph)를 이용하여 탐지.
   - 누가 누구를 대기하는지를 그래프로 만들면 교착상태인지 아닌지를 판별 가능.

   - 정점 V는 시스템 내의 `트랜젝션`으로 구성되며
   - 간선(정점과 정점을 연결하는 화살표) E는 트랜젝션의 순서쌍(Ti, Tj)로 이루어짐.
      - 간선이 있을 때는 트랜잭션이 다른 트랜젝션이 소유하는 데이터에 대한 락을 대기하고 있다는 것을 명시
      - Ti가 요청한 데이터의 락을 Tj가 소유하고 있으며, Ti는 Tj가 락을 반납하기 대기하는 상태.

   <img src="https://user-images.githubusercontent.com/66513003/117527647-899e1e00-b008-11eb-98bd-f0ed043c7271.png" width="400">

   - 현재 DBMS 내부에는 총 네개의 트랜젝션이 동시에 실행되고 있음
   - T12는 T13이 가지고 있는 데이터 항목에 대한 락을 요청해서 대기중.
   - T12는 T14의 데이터 항목을 락을 걸기 위해 대기중
   - T14는 T13을 대기.
   - T13은 T15를 대기.
   - 교착상태는 아님. 
   - T15 처리가 끝나면 락을 반납해서 T13이 처리하게 되고, T13이 끝나면 바로 T14가 락을 획득해서 처리할 수 있게 되고 그 다음 T12가 모든 데이터에 대한 락을 확보하고 처리 할 수 있게 된다.

   <img src="https://user-images.githubusercontent.com/66513003/117527560-e9e09000-b007-11eb-9e30-39cf54dbb9f0.png" width="400">
   
   - T13 -> T15 대기
   - T15 -> T14 대기
   - T14 -> T13 대기
   - 교착상태에 빠짐.
   - 대기 그래프에 `사이클(순환)`이 있다면 교착상태가 발생하여 회복절차 돌입.

## 교착상태의 회복
   1. `희생자` 선정 : 롤백 비용이 가장 적은 트랜잭션을 선택
      - 연산을 수행한 시간과 남은 작업을 마치기 위한 시간.
         - 지금까지 30분을 수행했지만 앞으로 2시간을 더 해야 한다면 롤백해도 무방.
      - 사용한 데이터와 트랜잭션 실행에 필요한 추가적인 데이터.
         - 데이터를 이미 많이 확보한 트랜젝션보다 앞으로 많이 확보해야 할 트랜젝션을 희생자로 선정.
      - 롤백에 포함되는 트랜잭션의 개수.
         - 수행중인 트랜젝션 12345가 있을때, 123을 회복하는 것 보다 45를 롤백하는게 효율적.
      
   2. 희생자 롤백 : 어느 시점까지 롤백 할 것인지 결정
      - 전체 롤백 VS 교착상태를 해결하는 지점.
         - 원자성을 위해 처음부터 다시 원복할 수 있는 실행전의 상태로 롤백할 수 있는 반면, 중간에 세이브 포인트라는 거점을 마련해서 부분롤백 후 재수행해서 해결이 된다면 보다 연산량을 줄일 수 있으므로 어느쪽이 좋을지 판단해야 한다.

      - 모든 트랜젝션의 상태에 대한 정보를 부가적으로 유지
   
   3. 무한정 기다림 해결
      - T13, 14, 15가 교착상태라고 가정할 때,
      - 13을 롤백해서 14, 15를 해결
      - 다시 13를 수행하려 할때 16, 17과 또 교착 상태에 빠짐.
      - 이런 식으로 13이 계속 희생자가 되어 롤백이 계속되는 상태가 되어 영영 처리 못하는 경우가 발생할 수 있다.
      - 이를 starvation 상태(무한정 기다림)라고 한다.
      - 이 상태를 해결하기 위해 매번 같은 트랜젝션이 희생자가 되지 않도록 희생자가 된  횟수를 함께 고려해 선정.

#

# **정리하기**

- 동시성 제어는 다수의 트랜잭션이 동시에 동일한 데이터에 대해 읽기 연산을 수행하거나 갱신 연산을 수행하려고 할 때, 데이터의 무결성을 유지하면서도 동시에 실행될 수 있는 트랜잭션의 수를 제어하는 기법이다.

- 대표적인 동시성 제어 기법에는 `락 기반 규약`, 타임스탬프 `순서 규약`, `검증 기반 규약(protocol) `등이 있다.

- 락(lock)이란 한 트랜잭션이 데이터 항목에 접근하는 동안에는 다른 트랜잭션이 그 데이터 항목에 접근하는 것을 제어하는 기법이다.

- 락킹 기법에는 `공유 락(shared lock)`과 `배타 락(exclusive lock)`이 있다. 공유 락은 양립가능하지만 배타 락은 다른 공유, 배타 락과 양립될 수 없다.

- 2단계 락킹 규약(two–phase locking protocol)은 각 트랜잭션이 락을 요청하는 단계와 언락을 요청하는 두 단계로 구성되어 있다. 트랜잭션은 `요청 단계`에서부터 시작되며 필요에 따라서 락을 요청할 수 있다. 만약 트랜잭션이 하나의 락을 반납하게 되면 그때부터 트랜잭션은 `반납 단계`로 되며 더 이상 락 요청을 할 수 없다.

- 타임스탬프 순서(timestamp ordering) 기법은 트랜잭션 충돌을 위해 직렬 가능한 순서를 정하는 데 가장 많이 사용하는 방법으로, 시스템의 각 트랜잭션마다 고유한 타임스탬프를 부여한다.

- 타임스탬프가 직렬 가능성을 보장하므로 TS(T1)＜ TS(T2)라면 시스템은 T1을 처리한 후 T2를 처리하여 직렬 스케줄과 동등하도록 보장한다.

