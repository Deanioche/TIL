## 포인터

___

포인터는 변수의 주소값을 저장.

포인터 변수를 선언할 때는 담으려는 자료형에 *(참조 연산자)를 붙인다.-+


```c
#include <stdio.h>

int main()
{
    int *p = NULL; // int* p == int * p 모두 같음
    int num = 15;

    p = &num;

    printf("&num (주소) : %d \n", &num);    // 6422296  
    printf("num에 담긴 값 : %d \n", num);   // 15
    //printf("*num의 값 : %d \n", *num);    // error 
    // num은 포인터변수로서 생성한게 아니기 때문에 에러

    printf("포인터 p의 값 : %d \n", p);      // 6422296  
    printf("&p (주소) : %d \n", &p);        // 6422300 -> p의 주소값.
    printf("*p가 가리키는 값 : %d \n", *p);  // 15

    return 0;
}
``` 

___

## **포인터 변수의 크기**

포인터 변수는 동일한 운영체제에서는 크기가 모두 동일하다.  
32비트 - 4 byte, 64비트 - 8 byte

포인터 연산을 할 때에는 그 주소로 찾아가 int, double에 따라 각각의 크기만큼 읽어들어야 하기 때문에
포인터 변수를 생성할 때 data-type을 지정해둔다.

포인터 변수는 값을 담아 초기화 할 수 없다.  
NULL(0) 또는 선언만 한 후에 특정 변수의 주소값을 담아주어야 한다.  

실수로 잘못된 주소를 다루게 되면 에러가 발생할 수 있기 때문에 **NULL로 선언**하는게 권장됨.

포인터 변수에 주소값을 담을 때는 
```
p = &num
```
형태로 담을 변수 앞에 &를 붙여준다.
여기서 p와 &num을 출력시켜보면 둘 다 동일한 주소값을 출력한다.

참조 연산자(*)가 붙으면 해당 포인터에 들어있는 주소로 찾아가 변수의 값을 가져온다.
```c
p = &num // 주소 출력
*p = num // 값 출력

(*p)++; // num++와 같음
*p++ // 쓰레기 값
```

'\*p++'은 num의 주소에서 1을 더한 값이 되므로, 아무것도 선언되지 않은 주소, 즉 쓰레기 값이 출력된다.
(연산 우선순위가 '++'이 '\*'보다 높다.)

포인터의 진가는 함수에서 발휘된다.

함수에서는 인자(argument)를 전달 할 때 복사해서 사용한다.  
즉, 전달해주는 원래 변수는 함수 내부에서 수정할 수 없다.

하지만 포인터로 함수의 파라미터에 메모리의 주소를 넘겨주면 함수에서도 메모리에 직접적으로 참조할 수 있게 된다.

## **함수에서 포인터의 사용**

```c
#include <stdio.h>

void pointerPlus(int *num)
{
	*num += 5;
}

void numPlus(int num)
{
	num += 5;	
}

int main()
{
	int num = 15;
	printf("num 값 : %d\n", num); // 15

	numPlus(num);
	printf("numPlus 사용 후 : %d\n", num); // 15

	pointerPlus(&num);
	printf("pointerPlus 사용 후 : %d\n", num); // 20

	return 0;
}
```

___

## **Call by value & Call by reference**

- Call by value  
    함수에서 값을 복사해서 전달하는 방식.  
    함수의 인자로 받은 변수는 원래와는 별개의 변수가 된다.  
    원본 값을 바꿀 필요가 없는 경우에 사용.

- Call by reference  
    함수에서 값을 전달하는 대신 해당 변수의 주소값을 전달하는 방식.  
    call by address라고도 한다.  
    C언어에서는 Call by reference를 공식적으로 지원하지는 않지만, 의미적, 결과적으로는 동일하게 동작한다.

```c
 #include <stdio.h>

int swapStudent(int *left, int *right)
{
	int temp;
	if(*right < *left) // left가 크면 right와 자리 바꿈
	{
		temp = *left;
		*left = *right;
		*right = temp;
	}
}

int main()
{
	int left;
	int right;
	scanf("%d", &left);
	scanf("%d", &right);
	
	swapStudent(&left, &right);
	
	printf("왼쪽 : %d, 오른쪽 : %d", left, right);
	
	return 0;
}
```
___

## **배열에서 포인터 연산**

배열의 이름 = 주소값 으로 동작한다.  
```c
#include <stdio.h>

int main()
{
	int arr[5] = {10, 20, 30, 40, 50};
	int *arrPtr = arr; // &를 붙이나 안붙이나 똑같이 주소값을 출력한다.

	printf("%d\n", *arrPtr); // 10
	printf("%d\n", arr[0]); // 10

	return 0;
}
```

포인터 연산은 덧셈, 뺄셈은 가능하지만 곱셈, 나눗셈은 할 수 없다.
