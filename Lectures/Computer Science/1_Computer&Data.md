# **컴퓨터와 데이터**

## **목차**

1. 컴퓨터
2. 컴퓨터 과학
3. 컴퓨터 시스템
4. 데이터와 정보
5. 진법
6. 정수 표현
7. 실수 표현
8. 문자 표현
___

## **1. 컴퓨터**

- 프로그램이 가능한 데이터 처리기
- 신속, 정확, 자동, 대용량

### **# 프로그램**
- 컴퓨터가 데이터를 어떻게 처리할지를 알려주는 일련의 명령어 집합
- 처리 가능한 작업의 유형과 연산의 집합을 결정
- 컴퓨터 → 특수 목적의 작업을 처리하는 기계가 아니라, "다양한 형태의 작업을 수행할 수 있는 범용의 기계".

- 프로그래밍 과정의 결과물
    - 주어진 문제의 해결 방법과 절차를 찾는다. → "알고리즘"
    - 그것을 적절한 프로그래밍 언어를 사용해서 컴퓨터가 이해할 수 있는 형태로 표현한다.

### **# 컴퓨터의 장점**

- 신속한 처리
    - ms (10^-3초), μs (10^-6초), ns (10^-9초), ps (10^-12초)

- 처리 결과의 정확성
    - 유효한 입력과 프로그램이 주어지면 항상 정확한 결과 생성

- 자동
    - 프로그램 지시에 따라 자동으로 처리 → 사람의 개입이 불필요

- 대용량
    - 대용량의 데이터 저장 및 처리

___

## **2. 컴퓨터 과학**

- 데이터의 획득, 표현, 처리, 저장, 통신, 접근과 관련된 학문
- 컴퓨터, 데이터, 프로그램, 알고리즘에 대한 학문
- 알고리즘과 관련된 이슈를 다루는 학문

- 데이터의 획득acquisition, 표현representation, 처리processing, 저장storage, 통신communication,  접근access을 위한 방법들의 실행 가능성, 구조화, 표현, 기계화에 관련된 내용을 다루는 분야.

- 알고리즘 : 주어진 문제를 해결하기 위한 처리 과정을 절차적으로 나열한 명령어들의 집합

- 컴퓨터공학
    - 가격 대비 성능 특성이 좋은 컴퓨팅 엔진을 만들기 위해 하드웨어와 소프트웨어 요소의 조립에 중점.
- 컴퓨터과학
    - 현재의 기술에 덜 의존적인 방식으로 주어진 문제에 대한 해결책의 효율성과 실현 가능성에 보다 중점.
    - 컴퓨터, 데이터, 프로그램, 알고리즘 분야의 연구를 통해 효율적인 자료 처리를 위한 제반 기술과 방법들을 제공.
    - "컴퓨터를 활용한 문제 해결에 대한 학문"

___

## **3. 컴퓨터 시스템**

- 하드웨어, 소프트웨어, 데이터, 사용자
- CPU(산술논리연산장치, 제어장치), 기억장치, 입출력장치
- 폰 노이만 모델 → 내장 프로그램, 프로그램은 유한 개의 명령어 나열

### **하드웨어**

- 핵심 장치 : 폰 노이만 모델에서 제시한 4개의 서브시스템.

- 폰 노이만 모델
    - 컴퓨터의 내부 구조와 처리 과정을 정의한 모델
    - 모든 컴퓨터는 폰 노이만 모델에 기반을 둠

- 기억장치 -> 주 기억장치, 보조기억장치
    - 처리할 입력 데이터, 처리를 담당하는 프로그램, 중간 결과, 출력할 데이터

- 산술 논리 연산 장치
    - 산술 연산과 논리 연산의 수행을 통해 직접적인 데이터 처리가 이루어지는 장치

- 제어장치
    - 컴퓨터의 기억장치, ALU, 입출력장치의 동작을 제어하는 장치

- 입력장치 : 키보드, 마우스, 마이크 ...
- 출력장치 : 모니터, 프린터, 스피커 ...

### **# 폰 노이만 모델의 주요 개념**

- 실행될 프로그램은 메모리에 저장되어야 한다.
    - 초기 컴퓨터에서는 데이터만 메모리에 저장되고, 프로그램은 컴퓨터 외부에 표현.

- "프로그램과 데이터가 **동일한 형식(비트 패턴)**으로 메모리에 표현된다"는 의미를 내포.

- 프로그램은 유한 개의 명령어의 나열이다.
    - 미리 정의된 기본 명령어의 유한 개의 조합으로 구성된다.
    - 메모리에서 한 번에 하나씩 명령어를 가져와서 해석하고, 실행한다.
    - 명령어의 재사용 → 프로그래밍 작업이 간단해짐.

### **# 소프트 웨어**

- 모든 종류의 프로그램을 총체적으로 표현하는 용어
    - 컴퓨터가 데이터를 어떻게 처리할 것인가를 규정하는 명령어들의 나열.
    - 컴퓨터가 이해할 수 있도록 표현된 알고리즘.

- 시스템 소프트웨어
    - 컴퓨터 자체의 작업 관리와 특정 기능의 수행을 통해 컴퓨터의 전체적인 운영을 담당.
    - 운영체제, 컴파일러 등

- 응용 소프트웨어
    - 사용자가 요구하는 작업을 직접적으로 수행하는 프로그램
    - 워드프로세서, 그래픽 프로그램, 데이터베이스 프로그램 등

### **# 데이터**

- 모든 데이터는 유형에 관계 없이 비트 패턴으로 표현
    - 비트 패턴 → 이진 상태를 나타내는 비트인 0과 1이 나열된 형태.
    - 폰 노이만 모델에서는 데이터의 표현 및 저장 형태에 대해서 정의하지 않음.

- 데이터의 입출력을 위해서는 적절한 형태로의 변환이 필요.
- 데이터 -(변환)-> 컴퓨터 -(변환)-> 결과

### **# 사용자**

- 사용자, 오퍼레이터
    - 컴퓨터의 설계부터 효율적인 이용에 이르기까지 전반적인 데이터 처리 과정에서 유능하고 지식이 풍부한 사람의 적극적인 개입이 필요.

___

## **4. 데이터와 정보**
- 데이터와 정보의 관계 → I=P(D) → “데이터를 대상으로 처리기에서 처리해서 얻은 결과가
정보이다.”
- 데이터 처리(정보처리) → 데이터를 정보로 가공하고 변환하는 일련의 과정
- 데이터 → 현실 세계로부터 관찰이나 측정을 통해 단순히 얻어지는 사실이나 값
- 정보 → 어떤 상황에 대해 적절한 의사결정을 수행할 수 있게 하는 지식
- 모든 데이터는 유형에 무관하게 비트 패턴이라는 일관된 방식으로 표현
- 데이터의 표현 단위 → 비트, 바이트, KB, MB, GB, TB, PB, EB, ZB, YB
    - 워드 → 컴퓨터 연산의 기본 단위가 되는 정보의 양

___

## **5. 진법**
- r진법 → 0, 1, …, (r-1)까지의 숫자만을 사용해서 수를 표현하는 방식/단위
    ![image](https://user-images.githubusercontent.com/66513003/137660727-df3e2b20-9421-4708-93d8-a3b7ed75515c.png)

- 각 위치에 따른 서로 다른 가중치(자릿값)가 존재
    ![image](https://user-images.githubusercontent.com/66513003/137661184-7d49f188-e5e8-4334-81cf-edd88306afab.png)

- 2진법, 8진법, 10진법, 16진법간의 변환이 필요
    - 2진수/8진수/16진수를 10진수로 변환 → 각 위치에서의 숫자값과 해당 위치에서의 가중치(자릿값)를 곱한 후, 그 결과들을 모두 더한다.
    - 10진수를 r진수로 변환 → 정수 부분과 소수 부분을 나눠서 각각 변환한 후, 그 결과를 단순히 연결해서 표현함
    - 2진수와 8진수/16진수의 관계 → 2진수의 3자릿수 = 8진수의 1자릿수, 2진수의 4자릿수 = 16진수의 1자릿수

- n진수 -> 10진수
    - 10진수 = (각 비트값 x 해당 비트 위치의 가중치)의 합.
    ![image](https://user-images.githubusercontent.com/66513003/137661266-06753329-a22f-4ecc-9fa6-85293b1f7ef3.png)
    ![image](https://user-images.githubusercontent.com/66513003/137661425-e89ae050-d964-4a6f-a940-ea09f29b1121.png)

- 10진수 -> r진수
    - 정수 부분과 소수 부분을 구분하여 각각 처리한 후, 각 결과를 단순히 연결해서 나열

    ![image](https://user-images.githubusercontent.com/66513003/137662218-5564ff8c-05eb-430a-9b99-5cc8a6c1af7e.png)

    - 10진수(**정수**부분) -> r진수
        ```js
        입력값 = 10진수(정수 부분); i = 0;
        몫 = 입력값 / r; 나머지 = 입력값 mod r;
        결과(i) = 나머지;
        while (몫 ≠ 0)
        입력값 = 몫; i = i+1;
        몫 = 입력값 / r;
        나머지 = 입력값 mod r;
        결과(i) = 나머지
        end
        출력[결과(i), 결과(i-1), …, 결과(0)];
        ```
        ![image](https://user-images.githubusercontent.com/66513003/137662331-34436dc3-3c73-4241-b74c-e43ca6758e9e.png)

     - 10진수(**소수**부분) -> r진수
        ```js
        입력값 = 10진수(소수 부분);
        i = 0;
        while (입력값 ≠ 0)
        임시변수 = 입력값 × r;
        결과(i) = 임시변수의 정수 부분;
        i = i+1;
        입력값 = 임시변수의 소수 부분;
        end
        출력[0.결과(0), 결과(1), …, 결과(i)];
        ```
        ![image](https://user-images.githubusercontent.com/66513003/137662457-8737702f-7734-46c8-b896-72dc70c718d1.png)
        ![image](https://user-images.githubusercontent.com/66513003/137662502-1f2b5750-a66b-43f1-a911-607454576d81.png)

    - 소수가 무한히 반복되는 경우  
        ![image](https://user-images.githubusercontent.com/66513003/137663364-9716a79e-4b08-4469-a86b-e5208680f663.png)
        - 소수가 계속 반복되는 경우에는 1회차에서 강제로 끊어준다.
        - 즉, 0.6을 2진수로 바꾸면 0.1001이 되지만, 같은 값은 아니고 **근사치**가 된다.
        - **0.6 ≈ 0.1001**

    - 2진수 <-> 8, 16진수  
        ![image](https://user-images.githubusercontent.com/66513003/137664248-4e2a17e7-af9f-42a4-a9d6-151c14c232df.png)

        - 2진수 <-> 8진수
            2^3 = 8 이므로, 2진수의 세자리씩 묶는다.  
            위 그림에 따르면, 011 110 100 101 . 001 111 100이 되므로,각각 10진법으로 고치면
            **3 6 4 5 . 1 7 4**가 된다.

            
        - 2진수 -> 16진수
            2^4 = 16 이므로, 2진수의 네자리씩 묶는다.  
            0111 1010 0101 . 0011 1110 이므로, **7 A 5 . 3 E**가 된다.
        
___

## **6. 정수 표현**
- 정수 표현 방법의 종류 → 부호 없는 정수, 부호 있는 정수
    - 부호 있는 정수의 표현 → 종류: 부호화-크기 방식, 1의 보수 방식, 2의 보수 방식 → 양의 정수는 모두 동일한 형태를 갖지만, 음의 정수의 경우에는 서로 다른 형태를 가짐
    ![image](https://user-images.githubusercontent.com/66513003/137665685-f1f64bfc-bbec-4dda-99f6-edd1e4071cc8.png)

### **# 부호 없는 정수**  
→ 부호 비트가 없으며, 주어진 n비트 전체를 사용해서 정수(0~2n-1)를 표현  
![image](https://user-images.githubusercontent.com/66513003/137665200-80e509cb-1f4b-4a77-ab7c-c4fcbe747ae6.png)

### **# 부호 있는 정수**  
![image](https://user-images.githubusercontent.com/66513003/137665257-24666f30-f6d2-40e5-985b-2064f5203071.png)

 - 부호화-크기 방식 → 최상위 1비트를 부호 비트로 사용하고, 음의 정수는 음수에 대한 절대값으로
   표현
 - 1의 보수 방식 → 부호 비트 사용. 음의 정수는 양의 정수 표현에 대한 보수(0→1, 1→0)를 취해서
   표현
 - 2의 보수 방식 → 부호 비트 사용. 음의 정수는 1의 보수 방식의 결과에 1을 더해서 표현

## **7. 실수 표현**
 - 부동소수점 방식을 사용해서 표현
  • 표현 형식 → (-1)부호×가수×2지수 → 부호(1비트)+지수(m비트)+가수(n비트)
 - 지수의 표현
  • 초과표기법 → 부동소수점의 지수 부분만을 위한 표기 방법으로, m비트가 할당된 경우 두 개의
      매직 넘버(2m-1, 2m-1-1)가 존재
  • 지수값을 저장하는 경우 → (지수값 + 매직 넘버)를 이진수로 표현/저장
  • 저장된 지수값을 해석하는 경우 → 지수 부분의 이진수를 십진수로 변환한 값에서 매직 넘버를
      뺀다.
 - 가수의 표현
  • 정규화 → 소수점 바로 왼쪽에 오직 하나의 1만 있도록 소수점의 위치를 조정 → 가수값을 저장
      하는 경우에는 소수점 이하 부분만 저장

## **8. 문자 표현**
 - 각 문자마다 유일한 코드가 부여되며, 이를 위해 약속된 문자 체계가 필요
  • 대표적인 문자 체계의 종류 → ASCII (또는 확장된 ASCII), 유니코드