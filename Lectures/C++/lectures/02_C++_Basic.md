# C++_Basic memo

## **상수의 표현**

### **# 정수형 리터럴의 표현**

- 접두사를 이용한 진법의 표현

    | 표현 | 의미 |
    |:--:|:--:|
    | 159 | 10진수 int형 상수 |
    | 0b10011111 | 2진수 int형 상수 |
    | 0237 | 8진수 int형 상수 |
    | 0x9f | 16진수 int형 상수 |

- 접미사를 이용한 정수 리터럴의 자료형 지정

    | 표현 | 자료형 |
    |:--:|:--:|
    | 123 | int형 |
    | 123u | unsigned int형 |
    | 123L | long형 |
    | 123ul | unsigned long형 |
    | 123ll | long long형 |

### **# 문자 리터럴의 표현**

- 작은 따옴표(' ') 안에 문자를 표기하는 방법
- 8진수나 16진수 문자 코드로 표기하는 방법

| 표현 | 의미 |
|:--:|:--:|
| 'A' | 문자 ‘A’ (ASCII 코드에 해당되는 정수 65와 동일) |
| '\101' | 'A'와 동일함 (65의 8진수 표현) |
| '\x41' | 'A'와 동일함 (65의 16진수 표현) |

### **# 실수 리터럴의 표현**

- 소수점이 있거나 10의 거듭제곱을 표현하기 위한 지수 기호인 ‘e’가 있으면 실수형 리터럴이다.

    ![image](https://user-images.githubusercontent.com/66513003/138105051-42525651-c976-41a8-891f-1b56381dcb27.png)

___

## **변수 variable**

### **# 변수의 초기화**

- 형식1. int total = 0;
- 형식2. int total(0);
    ```cpp
    float y(x); // 1로 초기화
    int x = 1.5; // 1로 초기화
    ```
- 형식3. int total = {0};
    ```cpp 
    short x{total}; // 오류: 축소 변환
    float y{total}; // 오류: 축소 변환
    ```

### **# 자료형 추론**

- 변수를 초기화할 때 초기화하는 값의 자료형으로 변수의
자료형을 추론함

```cpp
auto i(10); // int i(10); 과 동일함
```

### **# const 한정어**

- 변수의 값을 수정할 수 없게 함
- 초기화를 통해서만 값을 정할 수 있음
    ```cpp
    const double PI {3.14159}; // 원주율 정의

    #define PI 3.14159 // 매크로 상수 정의
    ```

### **# constexpr 한정어**

- 그 값을 **컴파일할 때** 평가한다는 의미
- 실행 중 값을 평가하는 것에 비해 효율적으로 동작할 수 있게 함

```cpp
int a;
std::cin >> a; // 사용자 입력은 컴파일이 된 후에 받는다.
const int b = 20;
const int C1 = a; // cin을 통해 입력된 a의 값으로 초기화
constexpr int C2 = a + 10; // 오류: 컴파일 시에 a의 값을 알 수 없음
constexpr int C3 = b + 100; // b + 100을 컴파일 시에 계산할 수 있음
constexpr int C4 = C1 * 2; // 오류: 컴파일 시에 C1의 값을 알 수 없음
```

### **# constexpr 함수**

- 모든 인수가 constexpr인 경우 컴파일할 때 값을 구할 수 있게 함

```cpp
constexpr int fac(int n) {
return n > 1 ? n*f(n-1) : 1;
}
void f(int x) {
constexpr int a = fac(4); // 컴파일할 때 계산
int b = fac(x); // 실행 중 계산
......
}
```

### **# 변수의 유효기간**

- 자동 변수
    - 생성 시점 : 함수(함수 안의 블록)가 시작될 때
    - 소멸 시점 : 함수(함수 안의 블록)가 종료될 때

- 정적 변수
    - 생성 시점 : 프로그램이 시작될 때
    - 소멸 시점 : 프로그램이 종료될 때

```cpp
int x; // 전역변수 - 정적 유효기간
int f() {
    int y; // 지역변수 - 자동 유효기간
    static int z; // 정적 지역변수 - 정적 유효기간
    ……
}
```

###  **# 변수와 상수 사용 예** - CircleArea.cpp
    ```cpp
    #include <iostream>
    using namespace std;

    int main()
    {
        const double PI{3.14159};
        double radius;
        cout << "원의 반경을 입력하시오 : ";
        cin >> radius;
        double area = radius * radius * PI;
        cout << "원의 면적 = " << area << endl;
        return 0;
    }
    ```
___

## **연산자 operator**

- 대입 연산자

    | 수식 | 실행 결과 |
    |:--:|:--:|
    | a = 0; | a ← 0 |
    | a = b = 0; | b ← 0, a ← 0 |
    | a = b = 1.5 | b ← 1, a ← 1 |

- 비트 단위 논리 연산자

    - 논리 합 |, 논리곱 &, 배타적 논리 합 ^, 부정 ~

    - x는 0x35(0011 0101),
    - y는 0xf0(1111 0000)일 때

    | 수식 | 수식의 값 |
    |:--:|:--:|
    | x | y | 0xf5 (1111 0101) |
    | x & y | 0x30 (0011 0000) |
    | x ^ y | 0xc5 (1100 0101) |
    | ~x | 0xca (1100 1010) |

- 비트 이동 연산자
    - 좌측 이동 << : 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 좌측으로 이동
        - 우측의 비는 비트에는 0이 채워짐
    
        ![image](https://user-images.githubusercontent.com/66513003/138116100-b5ce497d-5f2a-424b-80ef-be4a0d09fe36.png)

    - 우측 이동 >> : 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 우측으로 이동
        - signed 형에 대해서는 부호를 유지할 수 있도록 부호와 같은 비트가 좌측의 비는 비트에 채워짐(구현에 따라 다름)

        ![image](https://user-images.githubusercontent.com/66513003/138116267-cbcd7200-12c3-44f1-b470-8d1e0c596996.png)

___

## **자료형의 반환**

### **# 묵시적 형 변환**

- 두 값 사이의 연산에서는 우선순위가 낮은 자료형의 값이 순위가 높은 자료형의 값과 같은 형으로 자동적으로 변환됨
- 여러 개의 연산으로 구성된 수식에서 묵시적 형 변환은 연산자 단위로 이루어짐
- 대입 연산자(=)는 값을 저장할 변수의 자료형으로 묵시적 형 변환을 함
    - 오차나 오버플로가 발생할 수 있으므로 주의해야 함

![image](https://user-images.githubusercontent.com/66513003/138116514-78579d7f-292c-4760-acea-8095492737c3.png)

### **# 형 변환 연산자**

- static_cast : 실행 중에 형 검사를 하지 않으며, 컴파일 할 때 수식에 지정된 그대로 변환함
- dynamic_cast : 기초 클래스와 파생 클래스 간의 포인터 또는 참조 형 변환이 프로그램 실행 중에 일어나도록 지시함
- reinterpret_cast : 포인터를 다른 자료형의 포인터나 정수 자료형으로, 또는 그 역으로 변환함
- const_cast : const 지정을 일시 해제함

- 형 변환 연산자 사용 형식
    ![image](https://user-images.githubusercontent.com/66513003/138118566-4bb73589-fce1-450c-bc7b-5118feaf15fe.png)

___

## **Quiz**

1. 변수 x, y가 모두 unsigned char 형이다. x의 하위 4비트는 변하지 않고 상위 4비트만 모두 0으로 만들려고 한다. y에는 어떠한 값을 가지고 있어야 하는가?

```
x &= y;
```

- 답 : 0x0f

위 수식은 x = x & y; 와 같다. &는 비트단위 논리 곱 연산자이다. 어느 비트의 값이 a일 때 a & 0은 a의 값에 관계없이 0이다. 반면 a & 1은 a가 0이면 0, 1이면 1이다. 즉, a & 1은 a와 같다. 그러므로 x의 값에서 0으로 지우고 싶은 비트는 0, 그대로 두고 싶은 비트는 1이 y에 들어 있다면 x의 원하는 비트를 0으로 지울 수 있다. 하위 4비트는 변하지 않고 상위 4비트만 0으로 만들려고 하므로 y는 2진수 00001111, 즉 **16진수 0x0f**를 저장하고 있으면 된다.

#

2. 다음의 변수 선언문 중 오류가 있는 것은?

    1. int a = 100;
    2. float b(20.0);
    3. int c = { 200 };
    4. int d{ 1.5 };

- 답 : 4

①과 ②의 형식은 C++11 이전부터 사용되던 형식으로 필요하다면 묵시적 형 변환을 통해 변수가 초기화된다. C++11에서 권장하는 ③이나 ④의 형식은 초깃값으로 사용된 수식에 대해 축소 형 변환이 일어나면 안 된다. ③은 200이 int형이므로 올바르지만 ④는 1.5가 double이므로 int형 변수를 초기화하려면 축소 형 변환이 필요하여 오류이다.