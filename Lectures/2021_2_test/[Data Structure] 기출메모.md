# **자료구조 기출메모**


## **?**
- Prim? Kruscal?
- 최소힙이란?
    - 루트가 가장 값이 작고 모든 노드는 자식노드보다 값이 작음 -> 승리트리
## **# 트리**
- 트리는 사이클이 없는 그래프

- BS 트리 - 이진 탐색 트리(binary search tree)  
    - 일반적으로 노드의 개수가 많아지면 트리의 높이가 커지게 됨
    - BS 트리가 2원(2-way) 탐색 트리임

    ![image](https://user-images.githubusercontent.com/66513003/145352136-9b79392b-f2bb-48c0-b3fd-4c4d69ea6d61.png)

    ![image](https://user-images.githubusercontent.com/66513003/145341377-53d270dd-227e-4a43-9b41-3d1dbe40e0b8.png)

    ![image](https://user-images.githubusercontent.com/66513003/145341516-907d5782-7487-434c-979a-608bd234ec87.png)

    ![image](https://user-images.githubusercontent.com/66513003/145341999-b88626cf-6145-4fe8-8bb8-6a99cfd54efa.png)

    ![image](https://user-images.githubusercontent.com/66513003/145342815-23d0e21d-6104-4b4e-accd-472c4d39307a.png)

    ![image](https://user-images.githubusercontent.com/66513003/145344747-d5401545-6d15-45f3-a43a-92e7f97c3566.png)

    ![image](https://user-images.githubusercontent.com/66513003/145344751-5f25dc4c-9d03-4f58-9401-4f0cae4e5b4f.png)

- Splay 트리 : 자주 탐색하는 키를 가진 노드를 루트에 가깝게 위치하도록 구성한 이진 탐색 트리
    - 최근에 사용하려고 접근한 노드 x를 루트에 위치시켜 트리를 재구성

- AVL 트리
    - 제한 조건을 완화하여 트리가 (완전한) 균형이 아닌 것을 허용함
    - 거의 완전한 균형 트리의 한 형태로 높이가 균형 잡힌 **높이 균형 트리**(height balanced tree)
    - 직접 탐색 성능이 매우 좋음
    - 노드 vi 의 왼쪽 서브트리 높이 와 오른쪽 서브트리 높이 가 최대 1만큼 차이가 남

    ![image](https://user-images.githubusercontent.com/66513003/145346938-b2678472-d635-4749-95e8-788ba1d3744c.png)

    ![image](https://user-images.githubusercontent.com/66513003/145346959-4a509b5d-13d5-4f9e-af88-f9dea922e0a3.png)

    ![image](https://user-images.githubusercontent.com/66513003/145346973-a503f81e-b6c4-45f1-9ab0-111584d56516.png)

- BB 트리(bound-balanced)
    - 무게가 균형 잡힌 트리 (weight-balanced tree)
    - 거의 완전히 (대략) 균형 잡힌 트리의 다른 종류로 무게가 균형 잡힌 트리
    - 노드의 양쪽 서브트리 무게가 균형을 유지하는 트리
    - 삽입이나 삭제 후에 트리를 완전히 균형 잡히게 유지하기 위해서는 O(n) 의 노드를 옮겨야 하는 반면에 AVL 또는 BB 트리는 O(log 2n) 개의 노드를 옮기면 되는 것으로 알려져 있음

- m원 탐색 트리
    - m원 탐색 트리는 서브트리의 균형 에 대해서는 특별히 제한하지 않음
    - BS 트리가 2원(2-way) 탐색 트리임
    - 트리의 노드가 m개 이하의 가지를 가질 수 있는 탐색 트리
        - 같은 수의 노드를 갖는 이진트리보다 낮은 높이의 m원 트리
    - 이진 탐색 트리의 확장된 형태임
    - 탐색 트리의 제한을 따르되 2개 이상(m 개 이하) 자식을 가질 수 있음
    -  m-원 멀티 트리의 조건
        - i=0, ···, n-2인 i에 대해 ki ＜ ki+1를 만족한다.
        - i=0, ···, n-1인 i에 대해 pi가 가리키는 서브트리의 모든 키값은 ki의 키값보다 작다. 
        - pn이 가리키는 서브트리의 모든 키값은 kn-1의 키값보다 크다.
    -  노드가 자식을 많이 갖게 하여 트리의 높이를 줄이고 전체적으로 균형을 유지한다면 탐색 성능을 더욱 향상할 수 있음

    ![image](https://user-images.githubusercontent.com/66513003/145356514-e28bde49-d64f-4e81-b2ee-c557b3d4bc9e.png)

- B트리란?
    - 인덱스 구조를 구현하는데 가장 일반적으로 사용하는 방법으로 차수가 m인 트리
        - 차수 m 인 B 트리의 탐색 경로 길이는 같은 개수의 키를 가지는 이상적인 m 원 탐색 트리보다 길 수 있지만 키값을 삽입 /삭제할 때 B 트리를 유지하는 것이 더 쉬움
    - 트리의 모든 잎 노드는 같은 레벨에 있음
    - 루트와 잎 노드를 제외한 트리의 각 노드는 최소 ⌈m/2⌉개의 서브트리를 갖습니다.
    - 트리의 루트는 최소한 2개의 서브트리를 갖는다.
- B* : 노드의 약 2/3 이상이 차야하는 B 트리
    - 삽입 /삭제 시 발생하는 노드 분리를 줄이려고 고안됨
    - 노드가 꽉 차면 분리하지 않고, 키와 포인터를 재배치하여 다른 형제 노드로 옮김
    - 차수가 m 인 B* 트리는 다음 조건을 만족하는 B 트리이다 
        - 공집합이거나 높이가 1 이상인 m 원 탐색 트리이다 .
        - 루트 노드는 2 개 이상 2 ⌊(2m -2)/3 ⌋+1 개 이하의 자식노드 를 갖는다 . 
        - 내부노드는 최소한 ⌈(2m -1)/3 ⌉개의 자식노드 를 갖는다 . 
        - 모든 잎노드는 동일한 레벨에 놓인다 . 
        - 포인터가 k개인 잎이 아닌 노드는 k -1 개의 키를 갖는다. (루트노드 포함 )

- B+ : 인덱스된 순차 파일을 구성하는데 사용됨
    - B 트리와 같이 각 노드의 키가 적어도 1/2이 채워져야 하는 점은 같음
    - 잎노드를 순차적으로 연결하는 포인터 집합이 있다는 점에서 다름
        - 잎노드의 마지막 포인터를 다음 키값을 갖는 노드를 가리킴
        - 순차 처리를 할 때는 이 포인터를 이용해서 (키값을 비교하지 않고) 차례로 다음 데이터에 접근해서 처리
        - 모든 키값이 잎 노드에 있고 
        - 그 키값에 대응하는 실제 데이터에 대한 주소를 잎 노드만이 가지고 있음
        - 직접 탐색은 잎노드에 도달해야 종료

#

- 1-2트리
- 2-3트리
    - 2-노드와 3-노드만으로 구성한 트리로 B 트리 계열과 거의 같은 성능을 유지하면서 상대적으로 삽입 삭제가 용이함
- 2-3-4트리
    - 2-3트리보다 삽입 및 삭제 연산을 수행하는데 더 효율적
    - 2-3-4 트리 : 2-노드, 3-노드 및 4-노드만으로 구성한 트리로 2-3트리와 같은 특성을 가짐
    - 루트가 lchild인 모든 2-3-4 서브트리 키값은 lkey 보다 작다.
    - 루트가 lmchild인 모든 2-3-4 서브트리 키값은 lkey 보다 크고 mkey 보다 작다.
    - 루트가 rmchild인 모든 2-3-4 서브트리 키값은 mkey보다 크다.
- 레드 블랙 트리(red black tree)
    - 2-3-4 트리를 이진 트리로 나타낸 것으로 기억장소를 효율적으로 사용할 수 있음
    - 레드 간선과 블랙 간선의 서브트리 포인터를 가짐
    - 레드 간선은 2-3-4 트리의 한 노드 내에 있던 노드의 관계이고, 블랙 간선은 2-3-4 트리의 부모-자식 관계임

- 삽입이나 삭제 후에 트리를 완전히 균형 잡히게 유지하기 위해서는 O(n)개의 노드를 옮겨야 하는 반면에 AVL 또는 BB 트리는 O(log2n)개의 노드를 옮기면 되는 것으로 알려졌습니다.

## **# 그래프**
- 그래프 : 정점 집합 V와 간선 집합 E에 대하여 그래프는 G=(V,E)
    - 대상(V)과 그 대상들의 관계(E)를 나타내는 수단
- 정점 : 그래프를 구성하는 대상
- 간선 : 그래프에 있는 대상들의 관계
- 방향 그래프 : 간선의 방향이 유의미한 그래프
- 무방향 그래프 : 간선의 방향이 무의미한 그래프
    - 단, 도로가 일방통행로라면 간선의 방향은 의미를 갖고 그 그래프는 방향 그래프
- 다중 그래프 : 두 정점쌍이 간선을 여러 개 가질 수 있는 그래프
    -  두 지점사이에 여러 교통수단이 있다면 다중 그래프
- 가중 그래프 : 간선이 중요도/비용 등을 나타내는 가중 값을 갖는 그래프
    -  두 지점 사이를 연결 하는 도로의 거리가 중요한 의미를 갖는 문제라면 그 그래프는 가중 그래프로 표현
- 경로 : 두 정점을 잇는 간선 열
    - 경로에 있는 간선의 수를 그 경로의 경로 길이로 정의
- 루프 : 한 정점에서 출발하여 자신으로 연결하는 간선
    - 입력에 따라 상태가 변하는 시스템을 그래프로 나타내는 경우 어떤 입력에 대해서는 상태가 변하지 않는다면 루프로 표현
- 사이클 : 시작점과 끝점이 같은 경로
    - 하나 이상의 사이클을 갖는 그래프를 사이클이 있는 그래프 혹은 사이클 그래프
    - 사이클이 없는 그래프를 무 사이클 그래프 혹은 트리
- 사이클이 있는 그래프 : 하나 이상의 사이클을 갖는 그래프
- 무 사이클 그래프 : 사이클이 없는 그래프, 트리
- 인접 : 두 정점이 간선으로 연결되었을 때 두 정점은 인접함
    - 두 정점이 잇는 경로가 있다는 것과 반드시 구분
- 인접 행렬 : 그래프의 표현방법의 하나로 정점 사이의 인접성을 행렬로 나타낸 것
- 인접 리스트 : 그래프의 표현방법의 하나로 정점 사이의 인접성을 연결 리스트로 나타낸 것
- 그래프가 정점 개수에 비하여 간선 개수가 적으면 연결 리스트로 나타내야 기억 장소를 효율적으로 사용할 수 있음.

- 그래프 순회 -> DFS, BFS
    - DFS (깊이 우선 탐색) : 스택 이용
    - BFS (너비 우선 탐색) : 큐 사용

- 신장 트리(spanning tree) : 그래프 G의 모든 정점과 간선의 일부 (또는 전부)를 포함하는 트리
    - 주어진 그래프의 정점을 모두 포함함
    - 최소 n-1 개의 간선으로 구성한 그래프
- G의 최소 부분 그래프 : 그래프 G의 부분 그래프 중에서 간선의 수가 가장 작은 것

     ![image](https://user-images.githubusercontent.com/66513003/145402056-a958fc11-f6ee-4270-83c5-4ed909f3db62.png)

     ![image](https://user-images.githubusercontent.com/66513003/145402109-90a88929-dbd9-4b2f-b051-e391bd759daa.png)

- 프림(Prim) 알고리즘
    - 최소 비용 신장 트리를 구하는 알고리즘
    - 그래프 전체에서 최소 비용을 갖는 간선 { 𝑢𝑢 , 𝑣𝑣 } 를 선택하여 이 간선을 최소 비용 신장 트리 T 에 추가함
        - 이 간선을 최소 비용 신장 트리 T 에 추가하였을 때 사이클을 형성하지 않으면 T 에 추가하고 아니면 무시함

- 크루스컬(Kruskal) 알고리즘
    - 남은 간선 중에서 무조건 최소 비용인 간선을 선택 한 후 사이클을 형성하지 않으면 그 간선을 선택함     
    - 중간 과정에 있는 T 는 하나의 트리가 아니고 여러 개의 분리된 트리, 즉 숲일 수 있음
    - 중간중간 트리가 여러개 생길 수 있음.

- 솔린(Sollin) 알고리즘
    - 간선이 하나도 없는 그래프의 모든 정점들로 구성된 숲에서 시작함
    - 단계가 거듭되면서 숲 내의 트리들이 최소 비용을 갖는 간선으로 연결
    - 병렬 프로그래밍
    - 코어가 여러개이면 성능 상승
___

## **2018**

`4`11`34` `13`14`3` 2`3`2`4?` `23?4`3 1`2`32`?`
11113 3114K 22234 14233 14323
   13 31     2234 14233  4  3

X 36 39 40 41 42 45 47 49 50 51 52 53 54 57 60

? 42 49 50 53 54 57 


## **X**
- I = P(D) - 정보 = 처리(자료)
- 일반트리 -> 이진트리 
    ![image](https://user-images.githubusercontent.com/66513003/145130105-78559050-855a-4009-9aac-a060e383346e.png)
    
- 알고리즘 조건 - 입출력, 유한성.
    -  유한 번의 명령어를 수행 후(유한 시간 내)에 종료한다.
- `<index, value>` -> 배열
- 행 우선 저장
    - [0, 0] -> [0, 1] -> [0, 2] -> ... -> [0, -1] -> [1, 0]  
- 열 우선 저장  
    - [0, 0] -> [1, 0] -> [2, 0] -> ... -> [-1, 0] -> [0, 1]
- 사용하지 않는 포인터를 이용해 이진트리 순회 -> 스레드 이진트리
- 부모 노드가 두 자식 노드보다 큰 값을 가짐 -> 패자트리
    - 작으면 승자트리
- 트리의 잎 노드 개수 -> 트리의 무게
- 노드의 좌우측 서브트리 높이가 최대 1 차이나는 트리 -> AVL 트리
- 사이클이 없는 그래프 -> 트리
- B 트리 -> 트리의 모든 잎 노드는 같은 레벨에 있음
- Kruscal 방법 -> 남은 간선 중에서 무조건 최소 비용 간선을 선택한 후 사이클 형성 X인 최소 비용 신장 트리 결정 방법.
- 다중 그래프 -> 두 정점쌍이 간선을 여러개 가질 수 있는 그래프
- 추상화 - 추상 자료형 - 알고리즘
- 구체화 - 자료형 - 프로그램

![image](https://user-images.githubusercontent.com/66513003/145134504-2dca6532-0c75-48cc-ac4d-a66ad7e65b04.png)

___

   13 31     2234 14233  4  3
___

## **2017**

4143`1` 1K`3`21 1314`2` 1`??`4`?` `3`1`41`3
4143`F` 1K`4`21 1314`3` 1`31`4`K` `4`1`32`3

X > 40 43 46 47 50 52 53 55 56 58 59



## **?**

- 진출차수?

- 신장 트리
    - 그래프의 모든 정점과 간선의 일부를 포함하는 트리.

- m원 탐색 트리
    - 서브트리에 대한 포인터가 가리키는 서브트리의 모드 키값은 

- 힢의 노드 삭제
    - 루트노드 삭제
    - 마지막 노드를 루트 노드로 옮기고
    - 정렬 -> 가장 작은 노드가 루트노드로 올라오고, 마지막 노드는 맨 뒤로 가짐
___

- 이진트리 순회  
    ![image](https://user-images.githubusercontent.com/66513003/145191737-a78d0ff9-ad1c-4de0-b525-92bacd2f214c.png)
    - 전위 ABCD
    - 후위 BDCA
    - 중위 BACD

___

4143K 1K`3`21 1`4`1`2`2 13`33`3 41323
4143F 1K`4`21 1`3`1`4`3 13`14`K 41323

___

![image](https://user-images.githubusercontent.com/66513003/145413113-f01801b9-68cb-4b60-b666-2cbcf994aea3.png)


___

43414

- 차수가 m인 B트리
    - 잎 노드를 순차적으로 연결하는 포인터 집합 **없음**
- m원 탐색 트리
    - 노드A의 왼쪽 서브트리에 있는 모든 노드의 키 값은 노드A의 키값보다 **작지는 않음**.
- B트리
    - 부모는 자식보다 큰 값을 가짐.
- 최소신장 트리
    - 숲관련 -> Kruscal

___

## **2016**

`4`143`2` 3124`3` 414`13` 43132 `?`4142
`2`143`3` 3124`4` 414`31` 43132 `2`4142

![image](https://user-images.githubusercontent.com/66513003/145429300-f0421af8-e96b-4e36-b0f2-a1a65764f745.png)

___

- 진입차수
    - 루트 노드는 0
    - 나머지 노드는 1
- 우선순위 큐의 작동방식
    - 삭제후 순서 상관없이 저장됨(정렬x)
- CPU 할당 -> 큐 (순서대로 처리)
- 연결리스트
    - 배열로 구현 0
    - 원소의 순서가 메모리에서 물리적 순서는 **아님**

___

## **2015**

41`4`24 22`4`1`1` 2`?`434 24`11`4 `132`4`4`
41`3`24 22`2`1`2` 2`1`434 24`32`4 `321`4`2`

___

![image](https://user-images.githubusercontent.com/66513003/145439030-f803bdee-bfc6-4abe-8be2-91f3db1e6fc6.png)

___

32244 22132 321

___

- 힢 선형구조?
- 똑같은 주소의 버킷으로 해싱 -> 충돌 (collision)
- 중위순회는 왼쪽 노드부터 출력
    - 왼 -> 자신 -> 우
- 레코드는 각 원소(필드)마다 고유한 이름이 있음.
- 제산 잔여 해싱
    - 키를 어떤 정해진 수 M 으로 나누어 나머지를 자료의 주소로 사용하는 방법
- Kruscal
    - 간선이 이미 T에 속한 간선들과 비교해서 사이클을 형성하지 않는 한 T에 포함시켜 최소 비용 신장 트리를 결정

