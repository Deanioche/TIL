# **스레드 트리**

## **학습개요**

- 이진 트리를 순회할 때 방문하지 않고 지나쳐온 노드를 저장하는 방법으로 스택을 사용했다. 하지만 스택에 저장하고 스택을 관리해야 하는 번거로움이 있었는데, 이러한 번거로움을 없애기 위한 새로운 방법이 **스레드 트리**이다. 

- 정해진 순회 방법에 따른 방문 순서를 유지하는 포인터를 스레드라고 한다. 그리고 스레드라는 포인터를 갖는 이진 트리를 스레드 트리라고 한다. 

- 스레드의 종류는 오른쪽 스레드와 왼쪽 스레드로 두 가지가 있다.
    - 오른쪽 스레드는 정해진 순회 순서에 따른 그 노드의 **후속 노드**를 가리킨다. 
    - 왼쪽 스레드는 그 노드의 **선행 노드**를 가리킨다. 

- 스레드 트리는 2가지 방법으로 구현할 수 있다. 
    - 한 가지는 스레드를 저장하는 포인터를 추가하는 방법이 있다. 
    - 즉, 왼쪽 스레드 포인터, 왼쪽 자식 포인터, 데이터, 오른쪽 자식 포인터, 오른쪽 스레드 포인터 필드로 노드 구조를 정하는 것이다. 
    - 이 방법은 기억 장소에 대한 부담이 있습니다. 
    
    - 다른 방법은 이진 트리를 위한 연결 리스트의 노드 구조를 그대로 사용하면서, 리프 노드에 있는 사용하지 않는 포인터를 활용하는 방법이다. 
    - 이 방법은 각 노드에 대해 포인터가 스레드로 사용 중인지 아니면 서브트리에 대한 포인터인지를 구분하기 위해 **tag 필드**를 사용해야만 힌다. 
    - 스레드를 사용한 만큼 편리한 점도 있지만, 트리에서 노드의 삽입과 삭제 연산은 복잡한 편이다. 

___

## **학습목표**

- 스레드 트리의 개념을 설명할 수 있다.

- 스레드 트리의 구현 방법을 설명할 수 있다.

- 스레드 트리의 순회 연산과 삽입, 삭제 연산을 설명할 수 있다.

___

## **주요용어**

- 스레드(thread) : 정해진 순회 방법에 따른 방문순서를 유지하는 포인터

- 스레드 트리 : 스레드라는 포인터를 갖는 이진 트리

- 오른쪽 스레드 : 정해진 순회 순서에 따른 그 노드의 후속 노드를 가리킴

- 왼쪽 스레드 : 정해진 순회 순서에 따른 그 노드의 선행 노드를 가리킴

- 이진 트리의 null 포인터 개수 : 2n-(n-1) = n+1개

___

## **학습목차**

01. 스레드트리의 정의

02. 스레드트리의 구현

03. 스레드트리의 연산(순회, 삽입, 삭제)

___

## **1. 스레드 트리의 정의**

### **# 원형 연결 리스트**

![image](https://user-images.githubusercontent.com/66513003/137505445-d79f7141-e9cd-4360-a4c5-995c9a020d82.png)
- 기본 연결 리스트와 원형 연결 리스트의 차이는 마지막 노드의 링크의 사용 여부.

### **# 스레드 트리**

![image](https://user-images.githubusercontent.com/66513003/137508292-a558a81b-f981-4053-ad8e-b20a29210166.png)
![image](https://user-images.githubusercontent.com/66513003/137508327-b15b23fe-708b-4ada-956a-6d2c889c224b.png)

- 이진 트리의 노드 순회 : 전위 순회, 중위 순회, 후위 순회

- 이진 트리의 노드를 순회할 때, 방문하지 않고 지나쳐 온 노드들은 스택에 저장하여 관리해야 하는 번거로움이 발생함

- 스레드 트리 : NULL값을 가리키는 링크에 ‘스레드’라는 포인터를 추가하여 트리 순회를 편리하게한 것

- 스레드 : 순회 방법에 따른 방문순서를 유지하는 포인터

### **# 세 가지 순회에 대한 스레드 트리**

- 전위 순회  
    ![image](https://user-images.githubusercontent.com/66513003/137509803-e05eef51-b61d-4abb-9c92-6dfdbb71dbdc.png)

- 중위 순회  
    ![image](https://user-images.githubusercontent.com/66513003/137509867-8e2f7f02-0481-42f5-b1ec-a71bd6203f16.png)

- 후위 순회  
    ![image](https://user-images.githubusercontent.com/66513003/137509893-d814fbb5-2e2a-4f30-96db-32fba0a35b15.png)

각각 전위, 중위, 후위 표기법으로 연산을 한다. (3. 스택 참조)

___

## **2. 스레드 트리의 구현**

### **# 스레드의 구현 방법**

- 포인터 필드의 추가 : 스레드를 저장하는 포인터를 추가하는 것
    -  왼쪽 스레드 포인터, 왼쪽 자식 포인터, 데이터, 오른쪽 자식 포인터, 오른쪽 스레드 포인터 필드로 노드 구조를 정의함

- 오른쪽 스레드 : 정해진 순회 순서에 따른 그 노드의 후속 노드를 가리키고

- 왼쪽 스레드 : 그 노드의 선행 노드를 가리킴  

    ![image](https://user-images.githubusercontent.com/66513003/137510481-692e90c0-ef94-4d33-a1b6-811675c6fe1d.png)

- 포인터 필드의 추가
    ```c
    struct TNode
    {
        int info;
        TNode left;
        TNode right;
        TNode right_thread;
        TNode left_thread;
    }
    ```
    - 이전에는 없던 left_thread, right_thread의 추가로 메모리 낭비가 커진다.



- 추가된 포인터 필드를 이용한 중위 순회 연산
    ```c
    void inorder(struct TNode *firstin) { 
        struct TNode *p;
        p = firstin;
        while(p ! = NULL) {
            printf("%d", p->info);
            p = p->right_thread;
        }
    }
    ```
    - 중위 순회 연산(LPR)이므로 *firstin은 L 노드가 담긴다.
    - 여기서 L 노드란, 완전 이진 트리에서 가장 왼쪽의 리프노드가 된다. (중위 순회 연산의 시작)
        ![image](https://user-images.githubusercontent.com/66513003/137511927-b14e5de7-b96b-49bc-b2dc-2c33505b04a7.png)
        - 여기서 만약 A 또는 B 노드가 없는경우, + 노드에서 순회가 시작된다. (완전 이진 트리가 아니므로) -> 에러 발생

### **# 추가된 포인터 필드를 이용한 중위 순회 연산과정**

1. 순회할 트리의 시작 노드(중위 순회에서는 루트노드가 아닌 L 노드)를 가리키는 포인터 firstin을 매개변수로 하는 함수의 이름을 inorder()로 합니다.

2. 노드를 가리킬 수 있는 (TNode) 타입의 포인터 p를 생성하고 루트 노드를 가리키도록 합니다.

3. 포인터 p가 가리키는 데이터(info)를 출력하고 p를 p의 오른쪽 스레드 값으로 바꾸어 (p → right_thread) 중위 순회에 따른 다음 노드를 가리키도록 수정 합니다.

4. 이 과정을 p가 null이 될 때까지 반복합니다. 

![image](https://user-images.githubusercontent.com/66513003/137512430-ac2d14ce-dc8b-4394-abee-4abc19375dc1.png)
- right_thread만 찾아가면 중위 순회로 트리 안의 모든 노드를 탐색할 수 있다.


### **# 추가된 포인터 필드에 의한 스레드 구현**

- 스택을 운영하지 않고도 쉽게 트리에 속한 모든 노드를 순회 할 수 있음.

- 하지만 스레드를 위해 **추가적인 기억장소**를 사용한다는 부담이 생김. (left_thread와 right_thread의 추가)

### **# 스레드의 구현 방법**

- 스레드를 이용한 전위 순회

    ![image](https://user-images.githubusercontent.com/66513003/137514452-3ebd5eab-8b76-4456-80d1-d7ad74f9f66d.png)

    - 리프노드를 제외하고, left가 가리키고 있는 노드를 left_thread가 똑같이 가리키며 메모리가 낭비되고 있는 모습.
 
- 스레드를 이용한 중위 순회

    ![image](https://user-images.githubusercontent.com/66513003/137514770-a60376a1-31e7-457a-9afb-b500127aff96.png)

    - right가 가리키는 노드를 right_thread가 중복해 가리키고 있음. (낭비o)

- 스레드를 이용한 후위 순회

    ![image](https://user-images.githubusercontent.com/66513003/137514968-ebce8c68-88eb-4141-aec9-e46d1de0261d.png)

    - 후위 순회는 스레드와 child를 가리키는 링크가 동일한 부분이 없음. (낭비가 없다..?)

- **전위 순회**에서는 리프 노드의 NULL인 링크들을 활용하면, thread를 운용하지 않아도 되므로 낭비를 없앨 수 있다!

### **# 스레드의 구현 방법 2**

- 노드의 **빈 포인터** 필드를 활용 : 기존 이진 트리의 노드 구조를 그대로 사용하면서, 노드에 있는 사용하지 않는 포인터를 활용하는 방법

- 추가 기억장소를 사용하지 않아도 되는 장점이 있음

![image](https://user-images.githubusercontent.com/66513003/137515683-995b1bd2-9007-4509-9683-cf092f7134cb.png)

- 잎 노드의 빈 포인터 필드의 활용
    - 이진 트리의 포인터 갯수 (노드의 개수를 n개라 가정함) : 왼쪽 서브트리를 가리키는 포인터 n개 + 오른쪽 서브트리를 가리키는 n개 = 2n개의 포인터
    - NULL로 남는 포인터가 많다.

- 노드의 빈 포인터 필드의 활용
    - 루트 노드를 제외한 각 노드 개수는 모두 진입 차수는 ‘1’이 되므로,
    - 루트 노드를 제외한 전체 노드 즉, 누군가로부터 가리켜져야 할 노드의 개수 : n - 1
    - null이 아닌 포인터 개수 : n - 1
    - 2n - (n-1) = n+1개의 null 포인터가 노드에 존재함

- 2n - (n-1) = n+1개의 null 포인터를 스레드로 활용함
- 이진 트리의 중위 순회 : 어떤 노드 X에 대해 오른쪽 포인터가 null이면 이 포인터를 X 노드의 다음으로 순회되는 노드를 가리키도록 하고, 왼쪽 포인터가 null이면 X 노드의 바로 직전에 순회된 노드를 가리키게 함

# 37:47

___

## **정리하기**

- 스레드 트리는 기존의 이진 트리보다는 삽입과 삭제에 걸리는 시간이 많다.

- 검색할 데이터가 많아지면, 트리의 순회에 시간이 많이 걸리기 때문에 스레드를 이용해 최소화하고, 실제로 트리는 삽입, 삭제 연산이 빈번히 일어나지 않기 때문에, 번거롭더라도
검색과 분류에 많은 시간을 할애하는것 보다는 스레드를 이용해 관리하는게 훨씬 효율적이다.

- 그리고 트리는 삽입, 삭제에 대해 안정적인 자료 구조를 유지해 줄 수 있는 방법이 많다.

- 정해진 순회 방법에 따른 방문순서를 유지하는 스레드(thread)라는 포인터를 갖는 이진 트리를 스레드 트리라고 합니다.

- 오른쪽 스레드는 정해진 순회 순서에 따른 그 노드의 후속 노드를 가리키고 왼쪽 스레드는 그 노드의 선행 노드를 가리킵니다.

- 스레드를 구현 할 때 스레드를 저장하는 포인터를 추가하는 방법이 있습니다.

- 스레드를 구현 할 때 이진 트리를 위한 연결 리스트의 노드 구조를 그대로 사용하면서, 리프 노드에 있는 사용하지 않는 포인터를 활용하는 방법입니다.

- 노드가 n개인 이진 트리를 연결 리스트로 구현할 때 null 포인터는 항상 2n-(n-1) = n+1개가 존재합니다.

- 리프 노드에 있는 포인터를 활용하는 방법은 각 노드에 대해 포인터가 스레드로 사용 중인지 아니면 서브트리에 대한 포인터인지를 구분하기 위해 tag 필드를 사용해야만 합니다.