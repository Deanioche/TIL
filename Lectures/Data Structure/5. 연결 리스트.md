# **연결 리스트**

- ## **개요**
    - 리스트는 배열과는 달리 원소들 간의 논리적인 순서를 위한 자료구조이다. 
    - 원소들 간의 순서가 논리적으로(추상적으로) 지켜져야 하며, 각각의 원소가 저장되는 물리적인 위치가 연속적이든 불연속적이든 상관하지 않는다. 
    - 배열을 이용하여 리스트를 구현하면, 원소의 논리적인 순서를 지키기 위해 원소의 이동이 많아진다. 따라서 리스트를 구현하기 위해서는 일반적으로 포인터 변수를 이용한 연결 리스트를 이용한다. 
    - 포인터 변수의 사용과 동적인 메모리 할당 방법을 이용하면 리스트 구현 프로그램의 실행에 필요한 메모리의 낭비를 막을 수 있다. 연결 리스트의 노드의 삭제 연산과 삽입 연산은 포인터 변수를 활용한다. 
    - 포인터와 연결 리스트의 특징을 이해하고 넘어갈 것.

___

## **학습 목표**

- 리스트와 배열의 차이점을 나열할 수 있다.

- 연결 리스트의 구현을 위한 포인터 개념을 설명할 수 있다.

- 연결 리스트의 노드 삭제를 위한 포인터 변수의 운영에 대해 설명할 수 있다.

___

## **주요 용어**

- 리스트 : ‘원소들 간의 순서’가 지켜지며 유지되는 자료구조

- 리스트의 원소들 간의 순서 : 데이터가 저장되는 물리적인 위치와 상관없이 사람들의 머릿속에 인식되는 ‘논리적인 순서’, 혹은 리스트에 나타나는 원소들 간의 ‘의미적인 순서’

- 리스트의 노드 : 원소값과 다음 원소를 가리키는 위치의 주소값으로 구성된 자료단위, 데이터 요소(원소)와 리스트의 다음 원소를 지시하는 포인터(pointer, 주소)를 가지는 자료단위

- 포인터 : 메모리에 저장되는 값(데이터)의 저장 위치에 대한 주소를 가리키는 데이터형

- 단항 연산자 : 피연산자를 하나만 갖는 연산자

- 구조체(struct) : 다양한 데이터형의 변수를 하나의 상자 안에 넣어서 선언하거나 사용하는 C 프로그래밍 문법

___

## **목차**

01. 리스트의 개념

02. 배열을 이용한 리스트의 구현

03. 포인터를 이용한 리스트의 구현

04. 포인터 변수 및 리스트의 삭제/삽입

05. 연결리스트에서 노드의 삽입과 삭제

___

## **1. 리스트의 개념**

### **리스트의 의미**
- 일정한 순서의 나열
- 어떤 정의에 의해서 결정된 ‘논리적인 순서’의 나열


### **리스트의 정의**

**# 배열**  
- 원시적인 리스트

**# 리스트**
- 리스트의 '순서'는 물리적인 위치는 상관 x.
- 사람들에게 인식되는 '논리적인 순서', 또는 원소들 간의 '의미적인 순서'를 의미.
    - 예 : 3・1 운동, 대한독립, 6・25 전쟁, 서울 올림픽, ...
        ![image](https://user-images.githubusercontent.com/66513003/137302157-a5ca0162-9c96-4736-8d11-7f526b4187e7.png)
        - 메모리 상에서는 순서가 뒤죽박죽이지만, 화살표(링크)를 따라 가면 순서에 맞게 데이터에 접근 할 수 있다.
        - 즉, 실제 메모리의 적재와, 데이터의 **접근 순서**가 별개되는 점이 배열과 다르다.

- 리스트의 ‘순서’ 개념은 어떤 정의에 의해서 결정된 '논리적인 순서'.
- 원소들의 물리적인 저장 순서나 위치와는 무관하게 원소들 간의 논리적인 순서만 유지한다.

**# 리스트의 구현 방법**

- **포인터를 이용한** 리스트의 구현 방법
    - 원소값을 저장하는 공간과 다음 원소를 가리키는 위치 정보를 저장하는 공간을 함께 구현하는 방법.
- **배열을 이용한** 리스트의 구현 방법

___

## **2. 배열을 이용한 리스트의 구현**

- 구현해야 할 리스트를 3・1 운동(1919년), 대한 독립(1945년), 6・25 전쟁(1950년), 서울 올림픽(1988년)의 순서라고 정의한 뒤, 리스트에 '애국가 작곡(1936년)'을 삽입한다면?
    ![image](https://user-images.githubusercontent.com/66513003/137303011-31edcfce-61f0-4c7d-94e2-83a157cda257.png)

### **배열을 이용한 리스트의 원소 삽입/삭제**

- 배열은 굉장히 효율적이고 직관적으로 구현이 가능하지만, 실제로는 딱딱하고 융통성이 없는 자료 구조.

- ‘배열로 구현된 리스트’는 원소의 순서가 **연속적인 물리적 주소**에 저장된다.
    - 원소를 삽입하거나 삭제하기 위해서는 해당 원소의 위치 뒤에 있는 모든 원소를 뒤로 물리거나 앞으로 당겨야한다.
    - 리스트 원소값의 이동은 원소수가 많을수록 프로그램의 수행시간을 증가시킨다.

- 리스트의 원소 삽입은 프로그램의 실행 중에 **메모리 추가 할당**을 필요로 하는 경우도 발생시킨다.

- 자료의 삽입과 삭제가 빈번히 발생하는 상황에서 리스트를 배열로 구현하는 것은 빈번한 자료 이동으로 인한 비효율적인 컴퓨팅 성능을 유발한다.

- 따라서, 배열을 이용한 리스트의 구현은 실제 IT 서비스 환경에서는 자주 사용되지 않는다.
___

## **3. 포인터를 이용한 리스트의 구현**

### **노드의 구조**

- 노드(node) : 리스트의 원소(값) + 다음 원소를 가리키는 정보 
- 노드는 데이터 요소 (원소, 값) 와 리스트의 다음 원소를 지시하는 포인터 (주소, 링크(link))로 구성됨.

![image](https://user-images.githubusercontent.com/66513003/137305365-7dd62915-5f44-45cf-a944-541a8c4b82e6.png)

- **1919** : 데이터 요소 (원소, 값)
- **메모리 주소 값** : 포인터 주소

### **노드의 구조 및 연결**

![image](https://user-images.githubusercontent.com/66513003/137305846-11688d3a-cd65-44de-a274-720f0d44b8ff.png)

### **연결 리스트의 논리적 순서와 실제 메모리 표현**

![image](https://user-images.githubusercontent.com/66513003/137306118-aac90239-ed23-4052-bdf2-960e987f6515.png)

- 월요일 노드에는 메모리 주소 62의 링크가 담겨있다.
- 62는 화요일 노드를 가리킨다.
- 마지막으로 일요일 노드의 링크는 NULL(0)으로, 링크드 리스트가 종료된다.

___

## **4. 포인터 변수 및 리스트의 삭제 삽입**

### **리스트의 생성**

- 정수값 data와 링크 link 로 구성된 노드의 생성
    ```c
    struct linked_list_node {
        int data;
        struct linked_list_node *link;
    };
    ```
    - 구조체 linked_list_node의 멤버로 data, *link를 담는다.

### **포인터의 할당과 반환 예**
```c
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int a, *p_a;
    float b, *p_b;

    p_a = (int *)malloc(sizeof(int));
    p_b = (float *)malloc(sizeof(float));
    *p_a = 10;
    *p_b = 3.14;
    printf("a is %d, b is %f \n ", *p_a, *p_b);
    free(p_a);
    free(p_b);
    return (0);
}
```

### **포인터의 할당과 반환의 실행 결과**

![image](https://user-images.githubusercontent.com/66513003/137307045-bddedab0-d789-4700-ae31-bd039ed0e888.png)

- 파란색 박스는 포인터 변수에 malloc으로 할당한 메모리.

- 할당된 메모리의 **주소값**은 p_a(int - 4 byte)와 p_b(float - 8 byte)에 저장된다.

___

## **연결 리스트에서 노드의 삽입과 삭제**

### **연결 리스트에서 노드의 삭제**

- 연결 리스트의 노드 삭제  
    ![image](https://user-images.githubusercontent.com/66513003/137308290-15bd400c-4cd3-43d6-a4f9-f4b7da1fd454.png)

- 연결 리스트의 삭제 결과  
    ![image](https://user-images.githubusercontent.com/66513003/137308345-96afc8ec-3052-471d-9ea2-4641066cb470.png)

- 리스트의 원소 삭제 연산 단계

    - 삭제할 노드의 선행 노드의 링크 필드를 삭제할 노드의 후행 노드를 가리키게 한다
    - 삭제할 노드를 메모리에 반환한다.
        - 언어에 따라 가비지 컬렉터가 알아서 반환하거나 free 명령어로 수동반환.


### **# 연결 리스트에서 노드의 삽입**

- 연결 리스트의 삽입 노드  
    ![image](https://user-images.githubusercontent.com/66513003/137308549-1a45537e-ec6b-4f1c-a290-e7b6307ab52e.png)

- 연결 리스트의 삽입 결과  
    ![image](https://user-images.githubusercontent.com/66513003/137308607-eae7e0cd-eb53-45a1-b801-40c0c928c4f1.png)

- 리스트의 원소 삽입 연산 단계
    1. 메모리 공간을 할당받고 삽입할 내용을 저장하여 삽입할 x 노드를 생성합니다.
    2. x 노드의 링크부분이 후행 노드가 될 j 노드를 가리키게 합니다.
    3. 삽입될 x 노드의 선행 노드가 될 i 노드의 링크 필드가 x 노드를 가리키게 합니다.

### **# 연결 리스트의 마지막에 삽입 연산**

- 리스트 생성
    ```c
    void addNode(linkedList_h* H, int x) {
        // 리스트 마지막 노드에 삽입 연산하며, x값은 100이라고 가정함
        listNode* NewNode;
        listNode* LastNode;
        NewNode = (listNode*)malloc(sizeof(listNode));
        NewNode → data = x;
        NewNode → link = NULL;
    }
    ```

- 현재 리스트의 공백여부 체크 후 새 노드로 연결
    ```c
    void addNode(linkedList_h* H, int x) {
        if ( H → head == NULL) { // 현재 리스트가 공백인 경우
            H → head = NewNode;
            return;
        }
        LastNode = H → head;
        while(LastNode → link != NULL)
            LastNode = LastNode → link;
        LastNode → link = NewNode;
        return;
    }
    ```
    ![image](https://user-images.githubusercontent.com/66513003/137311167-ffe47270-ab31-41ef-a6c1-b853b3b779bb.png)

### **# 리스트의 특정 노드 다음에 삽입 연산**

```c
void additNode(linkedList_h* H, listNode* prevNode, int itdata) {
    NewNode → link = prevNode → link;
    prevNode → link = NewNode;
    return;
} 
```
![image](https://user-images.githubusercontent.com/66513003/137311342-93247e37-3b5c-4d80-b87e-40163079523f.png)

___

## **정리하기**

- 리스트의 ‘순서’는 데이터가 저장되는 물리적인 위치와 상관없이 사람들의 머릿속에 인식되는 ‘논리적인 순서’, 혹은 리스트에 나타나는 원소들 간의 ‘의미적인 순서’를 의미한다.

- 배열을 이용한 리스트의 구현은 실제 IT 서비스 환경에서는 자주 사용되지 않고 있습니다. 자료의 삽입과 삭제가 빈번히 발생하는 상황에서, 리스트를 배열로 구현하는 것은 빈번한 자료 이동으로 인한 비효율적인 컴퓨팅 성능을 유발한다.

- 포인터를 이용하는 방법은 원소의 자리에는 **원소값**을 저장하고, 다음 원소를 가리키는 정보의 자리에는 다음 원소가 저장될 위치의 **주소값**을 저장한다. 조금 더 ‘프로그램’스럽게 설명하자면, 리스트의 원소의 자리와 다음 원소를 가리키는 정보의 자리를 합쳐서 노드(node)라고 한다면, 노드는 데이터 요소(원소)와 리스트의 다음 원소를 지시하는 포인터(pointer, 주소)를 가진다고 생각하면 된다. 이 포인터는 링크(link)라고도 부른다.

- 포인터의 ‘메모리 주소값’이라는 것은 메모리에 저장되는 값의 위치라고 생각하면 됩니다. 메모리에 저장되는 값(데이터)은 저장 위치에 대한 주소를 가지며, 이 저장 위치를 이용해서 리스트의 원소값을 찾아갈 수 있다.

- 다양한 데이터형의 변수를 하나의 상자 안에 넣어서 선언하거나 사용하는 C 프로그래밍 문법이 구조체(struct)이다.